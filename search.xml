<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android 持续集成实践（一）：打包流程优化]]></title>
      <url>%2F2017%2F04%2F15%2Fandroid-ci-assemble-optimize%2F</url>
      <content type="text"><![CDATA[打包流程 具体实现Gradle配置文件归类 分类需要同步和不需要同步的配置文件，解决多分支模型下切换分支更改版本号等不需要同步的操作，gralde仍提示同步的问题，让真正需要同步的变更才提示。 新建version.gradle文件，添加变更时不需要同步的参数； 123456789101112131415161718192021ext &#123; // 打生产包命令：./gradlew assembleReleaseChannels // 打patch包命令：./gradlew buildTinkerPatchRelease // 当前编译状态，生产环境必须配置为false isDebug=true // 标识是否为补丁模式 isPatchModel=false // 是否上传符号表 uploadMappingEnable=false // 补丁模式，补丁文件对应的基准apk文件夹 patchBaseApkDir="" version_name="1.1.0.100" // 规则，年+月+日+当日发版次数 version_code=17041501&#125; 将version.gradle添加到项目根目录build.gradle顶部； 1apply from: 'version.gradle' 将变更时必须同步的参数统一添加到gradle.properties； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# =====================================以下为第三方账号配置=====================================// debugDEBUG_BUGLY_APPID="xxx"DEBUG_TALKINGDATA_APPID="xxx"DEBUG_MEIQIA_APPID="xxx"// releaseRELEASE_BUGLY_APPID="xxx"RELEASE_TALKINGDATA_APPID="xxx"RELEASE_MEIQIA_APPID="xxx"# =====================================以下为多dex配置=====================================MULTIDEX_KEEP_PROGUARD_FILE=multiDexKeep.proMULTIDEX_ENABLED=true# =====================================以下为签名配置=====================================SIGNING_STORE_FILE=xxx.keystore.jksSIGNING_STORE_PASSWORD=xxxSIGNING_KEY_ALIAS=xxxSIGNING_KEY_PASSWORD=xxx# =====================================以下为应用配置=====================================APPLICATION_ID=xxx# Sdk and toolsMIN_SDK_VERSION=16TARGET_SDK_VERSION=22COMPILE_SDK_VERSION=23BUILD_TOOLS_VERSION=25.0.0MULTIDEX_VERSION=1.0.0# =====================================以下为依赖配置=====================================# App dependencies# https://developer.android.com/topic/libraries/support-library/features.htmlsupportLibraryVersion=25.0.1guavaVersion=18.0junitVersion=4.12mockitoVersion=1.10.19powerMockito=1.6.2hamcrestVersion=1.3runnerVersion=0.4.1rulesVersion=0.4.1 检查multidex配置 Application启动时调用的类必须包含在主dex中，为此我们需要配置哪些类在主dex中。随着版本迭代或代码重构，可能导致配置的类包名发生改变或有新的类在Application中调用，为防止错误或遗漏，可在编译期引入自动检查机制，避免出错。 插件实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class CheckMultiDexKeepPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; System.out.println("==================================================================="); System.out.println("开始执行检查multiDexKeep.pro合法性插件，project.name：" + project.name); System.out.println("==================================================================="); final File multiDexKeepFile = new File(project.name, "multiDexKeep.pro"); if (!multiDexKeepFile.exists())&#123; throw new RuntimeException("请正确配置主dex keep文件"); &#125; // 生成appContext源文件路径 final String appContextClassPath = "com.zaozuo.android.app.AppContext.java"; final File appContextFile = javaClassPath2FilePath(project, appContextClassPath); System.out.println("AppContext File Path====================&gt;" + appContextFile.getAbsolutePath()); if (!appContextFile.exists())&#123; throw new RuntimeException("请正确配置AppContext Class路径"); &#125; // 读取appContext源文件中所有import非系统的行 System.out.println("read appContextLineList start====================&gt;"); final String firstLine = "-keep class " + appContextClassPath.replace(".java", ""); System.out.println(firstLine); List&lt;String&gt; appContextLineList = readImportNoSysLines(appContextFile); appContextLineList.add(firstLine); System.out.println("read appContextLineList end====================&gt;"); // 读取multiDexKeep文件中所有的行 System.out.println("read multiDexKeepLineList start====================&gt;"); List&lt;String&gt; multiDexKeepLineList = readLines(multiDexKeepFile); System.out.println("read multiDexKeepLineList end====================&gt;") final boolean multiDexKeepConfigSuccess = multiDexKeepLineList.containsAll(appContextLineList); if (multiDexKeepConfigSuccess)&#123; System.out.println("multiDexKeep配置正确，Good Lock!====================&gt;") &#125;else&#123; throw new RuntimeException("multiDexKeep配置不正确，请仔细检查后重试"); &#125; &#125; /** * 生成java源文件对应的文件路径 * @param project * @param javaClassPath * @return */ private File javaClassPath2FilePath(Project project, String javaClassPath)&#123; javaClassPath = javaClassPath.replace(".java", ""); final String[] tempArr = javaClassPath.split("\\."); final StringBuilder builder = new StringBuilder(); for (String temp : tempArr)&#123; builder.append("/").append(temp); &#125; builder.append(".java") final String appContextPath = builder.toString(); builder.setLength(0); final File file = new File(project.name + "/src/main/java/", appContextPath); return file; &#125; private final static List&lt;String&gt; sysClassNameList = new ArrayList&lt;&gt;(); static &#123; sysClassNameList.add("import android."); sysClassNameList.add("import com.android."); sysClassNameList.add("import java."); sysClassNameList.add("import dalvik."); &#125; /** * 读取appContext源文件中所有import非系统的行 * @param file * @return */ private List&lt;String&gt; readImportNoSysLines(File file)&#123; List&lt;String&gt; lineList = new ArrayList&lt;&gt;(); FileReader reader = new FileReader(file); BufferedReader br = new BufferedReader(reader); String str = null; while((str = br.readLine()) != null) &#123; if (str != null)&#123; if (str.startsWith(" "))&#123; str = str.trim(); &#125; if (str.startsWith("import"))&#123; boolean isSysClass = false; for (String sysClassName : sysClassNameList)&#123; if (str.startsWith(sysClassName))&#123; isSysClass = true; break; &#125; &#125; if (!isSysClass)&#123; str = str.replace("import ", "-keep class "); str = str.replace(";", ""); lineList.add(str); System.out.println(str); &#125; &#125;else if (str.startsWith("public class"))&#123; break; &#125; &#125; &#125; br.close(); reader.close(); return lineList; &#125; private List&lt;String&gt; readLines(File file)&#123; List&lt;String&gt; lineList = new ArrayList&lt;&gt;(); FileReader reader = new FileReader(file); BufferedReader br = new BufferedReader(reader); String str = null; while((str = br.readLine()) != null) &#123; if (str != null)&#123; lineList.add(str); &#125; System.out.println(str); &#125; br.close(); reader.close(); return lineList; &#125;&#125; 插件使用12// 在application类型模块下build.gradle中添加以下配置;apply plugin: com.zaozuo.plugins.CheckMultiDexKeepPlugin 多渠道打包 使用walle作为多渠道打包方案，比AndroidStudio提供的productFlavors方案性能更高，使用更方便，同时提供命令行工具方便临时增加渠道包。 1234567891011121314151617this.printlnLog("walle多渠道打包插件")apply plugin: 'walle'walle &#123; // 指定渠道包的输出路径 apkOutputFolder = new File("$&#123;project.bakPath&#125;", "$&#123;project.tinkerIdValue&#125;"); if (!apkOutputFolder.exists())&#123; apkOutputFolder.mkdirs() &#125; println("channeApkOutputFolder==========&gt;" + apkOutputFolder.getAbsolutePath()) // 定制渠道包的APK的文件名称 apkFileNameFormat = '$&#123;appName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;.apk'; // 渠道配置文件 channelFile = new File("$&#123;project.getProjectDir()&#125;/channel") println("channelFile==========&gt;" + channelFile.getAbsolutePath())&#125; 调整打包输出目录 项目中使用了bugly热修复和walle多渠道打包，打包输出的文件散落在各处，每次都需要手动归类备份；同时打正式包和Patch包需要备份的文件也不一样，比较繁琐容易出错。 插件实现 对外提供的配置类AdjustAssembleOutputConfig 1234567891011121314class AdjustAssembleOutputConfig &#123; String outputBakPath = null String outputBakDirName = null boolean isPatchModelValue @Override public String toString() &#123; return "AdjustAssembleOutputConfig&#123;" + "outputBakPath='" + outputBakPath + '\'' + ", outputBakDirName='" + outputBakDirName + '\'' + ", isPatchModelValue=" + isPatchModelValue + '&#125;'; &#125;&#125; 插件实现类AdjustAssembleOutputPlugin，分别针对打正式包和Patch包不同备份需求单独处理； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public class AdjustAssembleOutputPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; println("==================================================================="); println("开始执行AdjustAssembleOutputPlugin，project.name：" + project.name); println("==================================================================="); // 创建需要外部传入的配置文件 project.extensions.create("adjustAssembleOutputConfig", AdjustAssembleOutputConfig) // 获取最后编译完成的variant def targetVariant = null project.android.applicationVariants.all &#123; variant -&gt; def taskName = variant.name project.tasks.all &#123; if ("assemble$&#123;taskName.capitalize()&#125;".equalsIgnoreCase(it.name)) &#123; it.doLast &#123; targetVariant = variant println("$&#123;it.name&#125; doLast=========================&gt;") &#125; &#125; &#125; &#125; // build完成监听 project.gradle.addListener(new BuildListener()&#123; @Override void buildStarted(Gradle gradle) &#123; &#125; @Override void settingsEvaluated(Settings settings) &#123; &#125; @Override void projectsLoaded(Gradle gradle) &#123; &#125; @Override void projectsEvaluated(Gradle gradle) &#123; println("projectsEvaluated==========&gt;") &#125; @Override void buildFinished(BuildResult result) &#123; def buildSuccess = result.getFailure() == null println("buildFinished==========&gt;" + buildSuccess) if (!buildSuccess.toBoolean())&#123; return &#125; AdjustAssembleOutputConfig config = project['adjustAssembleOutputConfig'] def outputBakPath = config.outputBakPath def outputBakDirName = config.outputBakDirName def isPatchModelValue = config.isPatchModelValue println("isPatchModelValue======================="+isPatchModelValue) println("outputBakPath======================="+outputBakPath) println("outputBakDirName======================="+outputBakDirName) if (isPatchModelValue)&#123; // 打补丁包模式 adjustOutputForPatch(project, outputBakDirName, outputBakPath) deletePatchNewOfficialFile(project, outputBakDirName, outputBakPath) &#125;else&#123; adjustOutputForOfficial(project, outputBakDirName, outputBakPath, targetVariant.baseName) &#125; &#125; &#125;) &#125; /** * 删除打patch包时，生成的新的正式包文件 * @param project * @param outputBakDirName * @param outputBakPath * @return */ def deletePatchNewOfficialFile(Project project, outputBakDirName, outputBakPath)&#123; def newOfficialDir = findBuglyOutputFile(project, outputBakDirName, outputBakPath) if (newOfficialDir.exists())&#123; println("delete newOfficialDir==========&gt;" + newOfficialDir) newOfficialDir.deleteDir() &#125;else&#123; throw new RuntimeException("打patch包时，生成的新的正式包文件夹不存在：" + newOfficialDir) &#125; &#125; /** * 为patch包整理文件输出目录 * @param project * @param outputBakDirName * @param outputBakPath * @return */ def adjustOutputForPatch(Project project, outputBakDirName, outputBakPath)&#123; def patchFile = project.file("$&#123;project.rootDir&#125;/$&#123;project.name&#125;/build/outputs/patch/release/patch_signed_7zip.apk") if (patchFile.exists())&#123; // 目标文件目录 def toFileDir = new File("$&#123;outputBakPath&#125;", outputBakDirName) println("toFileDir==========&gt;" + toFileDir) // 拷贝补丁文件到备份目录 project.copy &#123; from patchFile into toFileDir &#125; // 压缩outputs文件夹并备份 def patchOutputFile = project.file("$&#123;project.rootDir&#125;/$&#123;project.name&#125;/build/outputs") println("patchOutputFile==========&gt;" + patchOutputFile) if (patchOutputFile.exists())&#123; FileUtils.compressedFile(patchOutputFile.getAbsolutePath(), toFileDir.getAbsolutePath()) &#125;else&#123; throw new RuntimeException("补丁outputs文件夹不存在：" + patchOutputFile) &#125; &#125;else&#123; throw new RuntimeException("补丁文件不存在：" + bakPath) &#125; &#125; /** * 为正式包整理文件输出目录 * @param outputBakDirName 备份文件夹名 * @param outputBakPath 备份目录 * @param buildType 当前编译模式类型 release/debug * @return */ def adjustOutputForOfficial(Project project, outputBakDirName, outputBakPath, buildType)&#123; // 定义输入文件名 def fromApkName = outputBakDirName + ".apk" def fromRName = outputBakDirName + "-R.txt" def fromMappingName = outputBakDirName + "-mapping.txt" def fromFileDir = findBuglyOutputFile(project, outputBakDirName, outputBakPath) println("fromFileDir==========&gt;" + fromFileDir) // 目标文件目录 def toFileDir = new File("$&#123;outputBakPath&#125;", outputBakDirName) println("toFileDir==========&gt;" + toFileDir) // 定义输出文件名 def toFileNamePrefix = "$&#123;project.name&#125;-$&#123;buildType&#125;" def toApkName = toFileNamePrefix + ".apk" def toApkFile = new File(toFileDir, toApkName) def toRName = toFileNamePrefix + "-R.txt" def toMappingName = toFileNamePrefix + "-mapping.txt" // 拷贝源文件目录下所有资源到目标文件目录，并重命名 project.copy &#123; // 拷贝目录下所有文件 from fromFileDir into toFileDir rename &#123; String fileName -&gt; fileName.replace(fromApkName, toApkName) &#125; rename &#123; String fileName -&gt; fileName.replace(fromRName, toRName) &#125; rename &#123; String fileName -&gt; fileName.replace(fromMappingName, toMappingName) &#125; &#125; // 删除源文件目录 if (toApkFile.exists())&#123; def deleteSuccess = project.file("$&#123;fromFileDir&#125;").deleteDir() println("delete fromFileDir==========&gt;" + deleteSuccess) &#125; &#125; /** * 查找bugly tinker打包输出的文件夹 * @param project * @param outputBakDirName * @param outputBakPath * @return */ def findBuglyOutputFile(Project project, outputBakDirName, outputBakPath)&#123; def fromApkName = outputBakDirName + ".apk" // 查找目标apk文件夹 def tree = project.fileTree(outputBakPath) &#123; include "**/$&#123;fromApkName&#125;" &#125; // 校验查找到的文件夹合法性 if (tree.size() == 0)&#123; throw new RuntimeException("没有找到APK文件:" + fromApkName) &#125; if (tree.size() &gt; 1)&#123; throw new RuntimeException("存在多个APK文件:" + tree.toString()) &#125; // 源文件目录 def fromFileDir = tree[0].getParentFile() return fromFileDir &#125;&#125; 插件使用 在application类型模块下build.gradle中添加以下配置; 1234567this.printlnLog("调整打包输出目录插件")apply plugin: com.zaozuo.plugins.adjustoutput.AdjustAssembleOutputPluginadjustAssembleOutputConfig&#123; outputBakPath "$&#123;project.bakPath&#125;" outputBakDirName "$&#123;project.tinkerIdValue&#125;" isPatchModelValue "$&#123;project.isPatchModel&#125;".toBoolean()&#125; 使用插件后，每次打包后输出的目录及文件; 检查生成的APK检查渠道配置come soon! 检查tinker配置come soon!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GoogleAnalytics在电商场景下的实践]]></title>
      <url>%2F2017%2F04%2F03%2Fandroid-ga-guideline%2F</url>
      <content type="text"><![CDATA[GA提供了多个维度的数据分析，覆盖了电商场景下所有的统计需求； 行为屏幕一级屏幕 二级屏幕 名词解释 二级屏幕：在一级屏幕基础上细分的二级屏幕； 屏幕名称：屏幕统计埋点，key的名字； 屏幕浏览量：屏幕pv，等于当前屏幕所有二级屏幕pv总和； 唯一屏幕浏览量：屏幕浏览会话数量（默认30分钟），等于当前屏幕所有二级屏幕会话数量的总和； 埋点位置Android Fragment/Activity onStart ； 如果是ViewPager+Fragment结构，需要在切换Tab(点击/滑动)时添加统计； iOS ViewController viewWillAppear； 如果是UIScrollView+ViewController结构，需要在切换Tab(点击/滑动)时添加统计； 从后台进入前台，需要添加统计； 埋点代码Android123456789101112131415161718192021222324252627282930313233343536373839404142private static Tracker getTracker()&#123; Tracker t = GoogleAnalytics.getInstance(ProxyFactory.getContext()).newTracker(trackingId); // 跨平台共享会话的唯一标识 final String cid = t.get("&amp;cid"); GAHelper.cid = cid; return t;&#125;/** * 带二级维度的屏幕统计 * @param screenName 屏幕名 * @param dimensionVaue 二级维度 */protected static void trackCustomDimensionPage(String screenName, String dimensionVaue)&#123; final Tracker t = getTracker(); t.setScreenName(screenName); // Send the custom dimension value with a screen view. // Note that the value only needs to be sent once. Map&lt;String, String&gt; build = new HitBuilders.ScreenViewBuilder() .setCustomDimension(1, dimensionVaue) .build(); if (BuildInfo.DEBUG) &#123; LogUtils.d(screenName + "==========&gt;" + dimensionVaue + ":" + build); &#125; t.send(build); // Clear the screen name field when we're done. t.setScreenName(null); if (BuildInfo.DEBUG)&#123; sendHitsNow(); &#125;&#125;/** * 立即发送ga数据 */private static void sendHitsNow()&#123; GoogleAnalytics.getInstance(ProxyFactory.getContext()).dispatchLocalHits();&#125; iOS123456789public static func trackCustomDimensionPage(screenName: String, dimensionVaue: String)&#123; guard let tracker = getTracker() else &#123;return&#125; // 设置一级屏幕 tracker.set(kGAIScreenName, value: screenName) // 设置二级屏幕 tracker.set(GAIFields.customDimension(for: 1), value: dimensionVaue) guard let builder = GAIDictionaryBuilder.createScreenView().set(dimensionVaue, forKey: GAIFields.customDimension(for: 1)) else &#123;return&#125; tracker.send(builder.build() as [NSObject : AnyObject])&#125; 常见问题一级屏幕浏览量 != 二级屏幕浏览量 (iOS) 埋点代码错误，tracker和builder都必须设置二级屏幕； 12tracker.set(GAIFields.customDimension(for: 1), value: dimensionVaue)//必须添加，否则会造成屏幕 guard let builder = GAIDictionaryBuilder.createScreenView().set(dimensionVaue, forKey: GAIFields.customDimension(for: 1)) else &#123;return&#125; 屏幕浏览量大于实际浏览量 (iOS &amp; Android) 产品列表展示统计造成的影响， 产品列表展示统计，会将当前一级屏幕及二级屏幕数据上传，解决方法是，强制将一级屏幕和二级屏幕参数值设置为空字符串； Android解决方案 1234// 必须添加以下参数，否则产品列表不显示 builder.set("&amp;t", "screenview"); builder.set("&amp;cd", ""); builder.set("&amp;cd1", ""); iOS解决方案 123// 特别注意：商品列表数据，必须强制设置屏幕及二级屏幕为空字符串，否则造成屏幕统计数量过多 tracker.set(kGAIScreenName, value: "") tracker.set(GAIFields.customDimension(for: 1), value: "") 行为流 行为流，是根据屏幕统计数据分析，得出用户在App内所有操作行为的展现，可以查看每个交互行为的转化； 应用速度 使用场景App启动时间的统计分析 App启动时间，特别是冷启动时间对启动率和留存率的影响还是蛮大的； 可以将App启动时间做二级维度的拆分，冷启动时间、热启动时间、CPU数量、内存大小、系统版本等，为启动时间的优化提供数据支持； API执行时间统计分析 服务端的API执行时间统计，是从接收到请求到处理完响应的过程，无法准确反应实际场景下用户的等待时间；在App端额外添加统计作为辅助； 可以对整个请求时间做二级维度的拆分，请求时间、响应时间、数据解析时间，做优化时有数据支持更有针对性； 其它业务场景下的统计分析 为版本迭代的效果提供数据依据，例如，订单确认页的改版是为了提高用户下单的效率，除了观察下单数量的变化外，在订单确认页到提交订单实际停留时间埋点更直接有效； 一些实际业务场景统计 订单确认页到提交订单实际停留时间； 购物流程耗时； 支付流程耗时； 注册流程耗时 分享流程耗时； 转化-电子商务产品列表业绩 名词解释 在产品列表中获得的浏览次数：列表请求次数 x 列表中所有商品的总和； 在产品列表中获得的点击次数：点击进入详情页的次数； 产品结账次数：进入自定义的checkout流程的次数；目前是进入订单确认页的次数； 唯一身份购买次数：商品实际支付成功的次数；例如：一个订单包含多件单品，单品也可能来自不同的产品列表，支付成功后该数据会体现在不同的产品列表中； 产品收入：实际支付成功的金额； 产品列表展示埋点位置 所有产品列表获取到网络数据，将新获取到的所有产品添加到统计； 首次进入页面获取数据； 请求数据失败重试； 下拉刷新； 加载更多； 埋点代码 Android 123456789101112131415161718192021222324252627282930313233/** * 跟踪产品列表 * @param impressionList * @param statProducts */ protected static void trackProductList(String impressionList, List&lt;StatProduct&gt; statProducts)&#123; if (StringUtils.isNotEmpty(impressionList) &amp;&amp; statProducts != null &amp;&amp; statProducts.size() &gt; 0)&#123; final HitBuilders.ScreenViewBuilder builder = new HitBuilders.ScreenViewBuilder(); int productCount = 0; for (StatProduct statProduct : statProducts) &#123; final Product product = toProduct(statProduct); builder.addImpression(product, impressionList); productCount ++; &#125; if (LogUtils.DEBUG)&#123; LogUtils.d("跟踪产品列表==========&gt;" + impressionList + ":" + productCount); &#125; // 必须添加以下参数，否则产品列表不显示 builder.set("&amp;t", "screenview"); builder.set("&amp;cd", ""); builder.set("&amp;cd1", ""); final Tracker t = getTracker(); t.send(builder.build()); if (BuildInfo.DEBUG)&#123; sendHitsNow(); &#125; &#125; &#125; iOS 12345678910111213141516171819202122232425262728293031323334353637public static func trackerItemProductList(className: String, impressionList: String, itemInfos: [ItemInfo]) &#123; guard let builder = GAIDictionaryBuilder.createScreenView() else &#123;return&#125; var productCount = 0 for item in itemInfos &#123; if let title = item.title, let price = item.price, let id = item.itemId &#123; productCount = productCount + 1 addProductImpressionToBuilder(id: String(id), name: title, price: price , impressionList: impressionList, builder: builder) &#125; &#125; sendProductList(className, impressionList: impressionList, builder: builder, productCount: productCount)&#125;private static func addProductImpressionToBuilder(id: String, name: String, price: Double , impressionList: String, builder: GAIDictionaryBuilder)&#123; let product = GAIEcommerceProduct() let customId = id + "-\(name)" product.setId(customId) product.setName(name) product.setBrand("xxx") product.setPrice(price as NSNumber!) builder.addProductImpression(product, impressionList: impressionList, impressionSource: nil)&#125;private static func sendProductList(_ className: String, impressionList: String, builder: GAIDictionaryBuilder, productCount: Int)&#123; guard let tracker = getTracker() else &#123;return&#125; // 特别注意：商品列表数据，必须强制设置屏幕及二级屏幕为空字符串，否则造成屏幕统计数量过多 tracker.set(kGAIScreenName, value: "") tracker.set(GAIFields.customDimension(for: 1), value: "") tracker.send(builder.build() as [NSObject : AnyObject]) zzlog(" Google Analytics className --&gt; \(className) 展示列表 --&gt;|\(impressionList)| --&gt; productCount:\(productCount)")&#125; 产品点击埋点位置 跳转到商品详情页点击事件； 埋点代码 Android 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 跟踪产品点击 * @param impressionList * @param statProduct */ protected static void trackProductClick(String impressionList, StatProduct statProduct)&#123; if (StringUtils.isNotEmpty(impressionList) &amp;&amp; statProduct != null)&#123; final Product product = toProduct(statProduct); final Tracker t = getTracker(); if (LogUtils.DEBUG)&#123; LogUtils.d("跟踪产品点击==========&gt;" + impressionList + ":" + statProduct.getName()); &#125; // detail final ProductAction detailAction = new ProductAction(ProductAction.ACTION_DETAIL) .setProductActionList(impressionList); final HitBuilders.ScreenViewBuilder detailBuilder = new HitBuilders.ScreenViewBuilder() .addProduct(product) .setProductAction(detailAction); // 必须添加以下参数，否则产品列表不显示 detailBuilder.set("&amp;t", "screenview"); detailBuilder.set("&amp;cd", ""); detailBuilder.set("&amp;cd1", ""); t.send(detailBuilder.build()); // click final ProductAction clickAction = new ProductAction(ProductAction.ACTION_CLICK) .setProductActionList(impressionList); final HitBuilders.ScreenViewBuilder clickBuilder = new HitBuilders.ScreenViewBuilder() .addProduct(product) .setProductAction(clickAction); // 必须添加以下参数，否则产品列表不显示 clickBuilder.set("&amp;t", "screenview"); clickBuilder.set("&amp;cd", ""); clickBuilder.set("&amp;cd1", ""); t.send(clickBuilder.build()); if (BuildInfo.DEBUG)&#123; sendHitsNow(); &#125; &#125; &#125; iOS 12345678910111213141516171819202122232425262728293031323334353637383940public static func trackerProductClick(className: String, id: String, name: String, price: Double, impressionList: String)&#123; guard let tracker = getTracker() else &#123;return&#125; var product = GAIEcommerceProduct() let customId = id + "-\(name)" product.setId(customId) product.setName(name) product.setBrand("xxx") product.setPrice(price as NSNumber!) guard let builder = GAIDictionaryBuilder.createScreenView() else &#123;return&#125; builder.addProductImpression(product, impressionList: impressionList, impressionSource: nil) product = GAIEcommerceProduct() product.setId(customId) product.setName(name) product.setBrand("xxx") product.setPrice(price as NSNumber!) let action = GAIEcommerceProductAction() action.setAction(kGAIPADetail) action.setProductActionList(impressionList) builder.setProductAction(action) builder.add(product) //tracker.set(kGAIScreenName, value: className) let detailBuilderDict = builder.build() as [NSObject : AnyObject] tracker.send(detailBuilderDict) zzlog("detailBuilderDict:\(detailBuilderDict)") guard let clickBuilder = GAIDictionaryBuilder.createEvent(withCategory: "Ecommerce", action: kGAIPAClick, label: nil, value: nil) else &#123;return&#125; let clickAction = GAIEcommerceProductAction() clickAction.setAction(kGAIPAClick) clickBuilder.add(product) clickAction.setProductActionList(impressionList) clickBuilder.setProductAction(clickAction) let clickBuilderDict = clickBuilder.build() as [NSObject : AnyObject] tracker.send(clickBuilderDict) zzlog("clickBuilderDict:\(clickBuilderDict)") zzlog("Google Analytics \(name) 在 |\(impressionList)| 列表中被点击了") &#125; 产品添加到购物车埋点位置 添加商品到购物车成功； 埋点代码 Android iOS 1234567891011121314151617181920212223public static func trackerAddItemProductToCartList(className: String, quantity: Int, itemInfo: ItemInfo) &#123; guard let tracker = getTracker() else &#123;return&#125; if let title = itemInfo.title, let price = itemInfo.price, let itemId = itemInfo.itemId &#123; let product = GAIEcommerceProduct() let customId = String(itemId) + "-\(title)" product.setId(customId) product.setName(title) product.setBrand("xxx") product.setPrice(price as NSNumber!) product.setQuantity(quantity as NSNumber!) let action = GAIEcommerceProductAction() action.setAction(kGAIPAAdd) guard let builder = GAIDictionaryBuilder.createEvent(withCategory: "Ecommerce", action: kGAIPAAdd, label: nil, value: nil) else &#123;return&#125; builder.setProductAction(action) builder.add(product) //tracker.set(kGAIScreenName, value: className) tracker.send(builder.build() as [NSObject : AnyObject]) zzlog(" Google Analytics 添加单品到购物车 --&gt; |\(builder.build() as [NSObject : AnyObject])|") &#125; GAIHelper.sendHitsNow() &#125; 结账行为 可以查看结账流程每一步的转化率； 名词解释 带来交易的会话：实际支付成功的会话数（默认30分钟视为一个会话）； 自定义Checkout流程埋点位置 订单确认页页面初始化位置； 点击确认订单按钮后，提交订单成功； 支付按钮点击事件； 埋点代码 Android iOS 123456789101112131415161718192021222324public static func trackCheckoutStep(orderSn: String, orderPrice: Double, items: [Item])&#123; guard let tracker = getTracker() else &#123;return&#125; guard let builder = GAIDictionaryBuilder.createEvent(withCategory: "Ecommerce", action: "Checkout", label: nil, value: nil) else &#123;return&#125; for item in items&#123; if item.isSuite ?? false&#123; if item.children != nil&#123; for subItem in item.children&#123; builder.add(createProduct(item: subItem)) &#125; &#125; &#125;else&#123; builder.add(createProduct(item: item)) &#125; &#125; // action let action = GAIEcommerceProductAction() action.setAction(kGAIPACheckout) // 根据checkout流程设置步骤数，目前为：1、2、3 action.setCheckoutStep(1) builder.setProductAction(action) tracker.send(builder.build() as [NSObject : AnyObject]) GAIHelper.sendHitsNow() &#125; Purchase埋点位置 App支付成功页面或服务端支付成功代码处； 埋点代码 Android iOS 1234567891011121314151617181920212223242526public static func onPurchaseCompleted(transactionId: String, revenue: Double, items: [Item]) &#123; guard let tracker = getTracker() else &#123;return&#125; guard let builder = GAIDictionaryBuilder.createEvent(withCategory: "Ecommerce", action: kGAIPAPurchase, label: nil, value: nil) else &#123;return&#125; for item in items&#123; if item.isSuite ?? false&#123; if item.children != nil&#123; for subItem in item.children&#123; builder.add(createProduct(item: subItem)) &#125; &#125; &#125;else&#123; builder.add(createProduct(item: item)) &#125; &#125; // action let action = GAIEcommerceProductAction() action.setAction(kGAIPAPurchase) action.setTransactionId(transactionId) action.setRevenue(revenue as NSNumber!) builder.setProductAction(action) tracker.send(builder.build() as [NSObject : AnyObject]) GAIHelper.sendHitsNow() zzlog(" Google Analytics 电子商务 支付完成：\(builder.build() as [NSObject : AnyObject])") &#125; 购物行为 名词解释 已结账的会话：进入自定义checkout流程的会话数； 带来交易的会话：实际支付成功的会话数； 销售业绩 销售业绩，显示的是实际支付成功的订单； 订单列表 订单详情 产品业绩 产品业绩，显示的是实际支付成功的商品； 常见问题产品列表业绩，无产品列表数据（Android）1234// 必须添加以下参数，否则产品列表不显示builder.set("&amp;t", "screenview");builder.set("&amp;cd", "");builder.set("&amp;cd1", ""); 产品列表业绩，无产品点击数据（Android）12345// 必须添加以下参数，否则产品列表不显示点击clickBuilder.set("&amp;t", "screenview");clickBuilder.set("&amp;cd", "");clickBuilder.set("&amp;cd1", "");t.send(clickBuilder.build()); 产品列表业绩，出现大量nosetApp端统计问题 添加了购物车列表的统计； 服务端统计问题 服务端在支付成功的统计中，将”t”对应的值写成了”pageview”，必须为”event” 1put("t", "event");//匹配的类型（订单支付成功就填这个） 必填 产品列表业绩，产品结账次数错误 产品结账次数，是进入checkout流程第一步的次数；如果有可能直接进入checkout流程第二步就会造成此数据不显示，应该考虑重构checkout流程； 结账行为，统计数据与实际数据差距较大 GA默认120秒定时发送缓存的统计数据，如果用户走完购买流程后直接退出App可能造成数据统计不全； 解决方案 可将checkout流程、添加到购物车、Purchase放在服务端埋点； App在checkout流程、添加到购物车、Purchase埋点时，主动调度GA发送数据； 12// 主动调度数据匹配GAI.sharedInstance().dispatch() App进入后台，主动调度GA发送数据； 123456789101112131415161718192021222324252627func applicationDidEnterBackground(_ application: UIApplication) &#123; sendHitsInBackground() &#125; func applicationWillEnterForeground(_ application: UIApplication) &#123; GAI.sharedInstance().dispatchInterval = 120 &#125; private var dispatchHandler:((_ result: GAIDispatchResult ) -&gt; ())? private func sendHitsInBackground() &#123; var taskExpired = false let taskId = UIApplication.shared.beginBackgroundTask &#123; taskExpired = true &#125; if (taskId == UIBackgroundTaskInvalid) &#123; return &#125; self.dispatchHandler = &#123;[weak self] (result) in if (result == GAIDispatchResult.good &amp;&amp; !taskExpired) &#123; GAI.sharedInstance().dispatch(completionHandler: self?.dispatchHandler) &#125;else&#123; UIApplication.shared.endBackgroundTask(taskId) &#125; &#125; GAI.sharedInstance().dispatch(completionHandler: self.dispatchHandler) &#125; 接入问题怎么区分开发/生产环境编译期区分生产/测试环境 Android可以在BuildConfig中，根据编译环境动态配置GA AppKey； iOS可以通过DEBUG宏动态配置GA AppKey； 运行期区分生产/测试环境 日常测试，下载生产环境的App，通过更改DNS连接到测试服务器测试，可能会造成统计数据发送到生产环境； 将GA AppKey在服务端根据环境动态下发到App； 查看GA日志Android1234567// Google Analytics（分析）将使用 Android Log 系统通过 GAv4 代码将日志记录到 logcat。// 默认情况下只启用 ERROR、WARN 和 INFO 级别。// 要启用 DEBUG 级别，请在您的设备或模拟器上运行以下 adb 命令：adb shell setprop log.tag.GAv4 DEBUG// 要只查看 logcat 中的 Google Analytics（分析）消息，请使用以下命令：adb logcat -v time -s GAv4 iOSAndroid接入后Crashjava.lang.NoSuchMethodError: No static method zzb(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object; in class Lcom/google/android/gms/common/internal/zzaa; or its super classes (declaration of 'com.google.android.gms.common.internal.zzaa' appears in /data/data/com.zaozuo.android/files/instant-run/dex/slice-com.google.android.gms-play-services-basement-9.2.0_838f224be8ca39a2f48a2f75d5178b0e700ad7c6-classes.dex) at com.google.firebase.provider.FirebaseInitProvider.zza(Unknown Source) at com.google.firebase.provider.FirebaseInitProvider.attachInfo(Unknown Source) at android.app.ActivityThread.installProvider(ActivityThread.java:5595) at android.app.ActivityThread.installContentProviders(ActivityThread.java:5168) at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5108) at android.app.ActivityThread.-wrap2(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1633) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:5896) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679) 参考资料： 开发文档：https://developers.google.com/analytics/?hl=en 调度文档：https://developers.google.com/analytics/devguides/collection/ios/v3/dispatch#implement-sendHitsInBackground 自定义维度和指标帮助文档：https://support.google.com/analytics/answer/2709828?hl=zh-Hans#scope Measurement Protocol 参数参考：https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters#events]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 网络层Library设计]]></title>
      <url>%2F2017%2F03%2F26%2Fandroid-network-framework%2F</url>
      <content type="text"><![CDATA[网络层Library是App最常用的库，需要考虑稳定性，后期的扩展性，更换核心网络库后对项目的影响，ZZNet采用okhttp作为核心网络库。 需求描述： 支持HTTP/HTTPS； 请求支持取消； 支持校验器，可用于统一的JSON校验； 支持拦截器，可用于缓存的处理； 支持重试次数和自定义重试规则； 支持文件上传，上传进度，多文件上传，取消上传； 支持文件下载，下载进度，断点续传，取消下载； 自动处理错误描述和详细的错误类型； 架构设计： 架构实现：ZZNetValidator，请求及响应校验器 可以针对单个请求配置校验器或所有请求配置统一的校验器，校验请求参数或响应数据的合法性等。例如：可以在请求前校验登录状态，在响应后校验服务端返回的token是否合法，是否需要重新登录等，可以在此处做统一的处理。 12345678910111213141516171819202122/** * 请求及响应校验器 */public interface ZZNetValidator &#123; /** * 校验参数合法性，运行在主线程 * @param zzNet * @param paramsSource * @return */ ZZNetResponse isCorrectWithParamsDataRunOnMainThread(@NonNull ZZNet zzNet , @NonNull Map&lt;String, String&gt; paramsSource); /** * 校验API响应合法性，运行在工作线程 * @param zzNet * @param response */ ZZNetResponse isCorrectWithCallBackDataRunOnWorkThread(@NonNull ZZNet zzNet , @NonNull ZZNetResponse response);&#125; ZZNetInterceptor，请求及响应拦截器 针对请求生命周期的各个阶段进行拦截，增强网络库的扩展性。例如：随着业务的发展，API如果需要引入缓存机制，可以在拦截器中处理，隔离或降低对业务层的侵入性。 12345678910111213141516171819202122232425262728/** * 请求及响应拦截器 */public interface ZZNetInterceptor &#123; /** * 通过所有校验，发起网络请求前执行，运行在工作线程。 * @param zzNet * @return */ @WorkerThread boolean beforeSendNetRequestRunOnWorkThread(@NonNull ZZNet zzNet); /** * 发送网络请求后执行，运行在工作线程。 * @param zzNet */ @WorkerThread void afterSendNetRequestRunOnWorkThread(@NonNull ZZNet zzNet); /** * 在callback的onDidCompleted方法前执行，运行在主线程 * @param zzNet * @param response */ @MainThread void beforeDidCompletedRunOnMainThread(@NonNull ZZNet zzNet, @NonNull ZZNetResponse response);&#125; ZZNetProcessor，网络请求及响应核心处理器 网络请求处理的抽象接口，把网络请求过程拆分为处理请求和处理响应，可以根据业务需要添加实现；目前有3个实现类，ZZNetStringProcessor（处理字符串类型的响应数据）、 ZZNetUploadProcessor（处理文件上传）、 ZZNetDownloadProcessor（处理文件下载）。 1234567891011121314151617@WorkerThreadpublic interface ZZNetProcessor &#123; /** * 处理请求参数 * @param requestBuilder */ @WorkerThread void handleRequestParams(@NonNull Request.Builder requestBuilder); /** * 处理请求响应 * @param response * @param responseEntity */ @WorkerThread void handleResponse(@Nullable Response response, @NonNull ZZNetResponse responseEntity); ZZNetStringProcessor，字符串处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 字符串处理器 */@WorkerThreadpublic final class ZZNetStringProcessor extends ZZNetDefaultProcessor &#123; public ZZNetStringProcessor(ZZNet zzNet)&#123; super(zzNet); &#125; /** * 处理String类型的响应 * @param response * @param netResponse */ @Override @WorkerThread public void handleResponse(Response response, ZZNetResponse netResponse) &#123; try&#123; if (response != null) &#123; if (response.isSuccessful()) &#123; netResponse.rawString = response.body().string(); if (checkJsonValid(netResponse))&#123; netResponse.errorType = ZZNetErrorType.Success; // validator校验响应结果 ZZNetValidator appValidator = zzNet.getBuilder().getAppValidator(); if (appValidator != null)&#123; appValidator.isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); &#125; if (zzNet.getValidator() != null)&#123; zzNet.getValidator().isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); &#125; &#125; &#125; else &#123; netResponse.errorType = ZZNetErrorType.ServerError; netResponse.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg4); &#125; &#125; else &#123; netResponse.errorType = ZZNetErrorType.NoResponse; netResponse.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg6); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); netResponse.errorType = ZZNetErrorType.Timeout; netResponse.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg10); &#125; &#125; /** * 检查json合法性，并解析json中错误码及错误描述，决定json是否可解析 * * @param responseEntity 响应实体数据，需先设置responseEntity.rawJson * @return */ private boolean checkJsonValid(@NonNull ZZNetResponse responseEntity) &#123; if (TextUtils.isEmpty(responseEntity.rawString)) &#123; responseEntity.errorType = ZZNetErrorType.JSONInValid; responseEntity.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg7); return false; &#125; if (responseEntity.rawString.startsWith("\ufeff")) &#123; responseEntity.rawString = responseEntity.rawString.substring(1); &#125; // parse error code return true; &#125;&#125; ZZNetUploadProcessor，文件上传处理器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 文件上传处理器 */@WorkerThreadpublic class ZZNetUploadProcessor extends ZZNetDefaultProcessor &#123; public ZZNetUploadProcessor(@NonNull ZZNet zzNet)&#123; super(zzNet); &#125; @Override public void handleRequestParams(Request.Builder requestBuilder) &#123; super.handleRequestParams(requestBuilder); handleUploadRequestParams(requestBuilder); &#125; private void handleUploadRequestParams(Request.Builder requestBuilder)&#123; if (zzNet.getUploadFile() != null &amp;&amp; zzNet.getUploadFile().exists())&#123; if (zzNet.getMediaType() == null)&#123; throw new NullPointerException("上传文件类型不能为空"); &#125; RequestBody rawRequestBody = RequestBody.create(MediaType.parse(zzNet.getMediaType()) , zzNet.getUploadFile()); if (zzNet.getMultipartFileKeyName() != null)&#123; MultipartBody multipartBody = new MultipartBody.Builder() .addFormDataPart(zzNet.getMultipartFileKeyName() ,zzNet.getUploadFile().getName(), rawRequestBody).build(); RequestBody requestBody = new ZZProgressRequest(multipartBody, zzNet.getFileCallback()); requestBuilder.post(requestBody); &#125;else&#123; RequestBody requestBody = new ZZProgressRequest(rawRequestBody, zzNet.getFileCallback()); requestBuilder.post(requestBody); &#125; &#125; &#125; @Override @WorkerThread public void handleResponse(@NonNull Response response, @NonNull ZZNetResponse netResponse) &#123; if (response == null)&#123; netResponse.errorType = ZZNetErrorType.NoResponse; netResponse.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg6); return; &#125; if (!response.isSuccessful())&#123; return; &#125; // 解析响应数据 try &#123; netResponse.rawString = response.body().string(); netResponse.errorType = ZZNetErrorType.Success; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; // validator校验响应 ZZNetValidator appValidator = zzNet.getBuilder().getAppValidator(); if (appValidator != null)&#123; appValidator.isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); if (netResponse.errorType != ZZNetErrorType.Success)&#123; LogUtils.d(zzNet.getUrl(), "appValidator校验响应不通过，终止"); return; &#125; &#125; if (zzNet.getValidator() != null)&#123; zzNet.getValidator().isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); if (netResponse.errorType != ZZNetErrorType.Success)&#123; LogUtils.d(zzNet.getUrl(), "apiValidator校验响应不通过，终止"); return; &#125; &#125; &#125;&#125; ZZNetDownloadProcessor，文件下载处理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * 文件下载处理器 */@WorkerThreadpublic final class ZZNetDownloadProcessor extends ZZNetDefaultProcessor &#123; private static final int DEFAULT_BUFFER_SIZE = 32 * 1024; // 32 KB public ZZNetDownloadProcessor(ZZNet zzNet)&#123; super(zzNet); &#125; @Override @WorkerThread public void handleRequestParams(Request.Builder requestBuilder) &#123; super.handleRequestParams(requestBuilder); handleDownloadRequestParams(requestBuilder); &#125; /** * 处理下载请求参数 * @param requestBuilder */ @WorkerThread private void handleDownloadRequestParams(Request.Builder requestBuilder)&#123; if (canAddRangeHeader())&#123; // 断点续传下载 requestBuilder.header("RANGE", "bytes=" + zzNet.getSaveFile().length() + "-"); &#125; &#125; /** * 能否拼接断点续传文件Range * @return */ @WorkerThread private boolean canAddRangeHeader()&#123; File saveOrUploadFile = zzNet.getSaveFile(); if (zzNet.isSupportResumeDownload() &amp;&amp; zzNet.getRequestModel() == ZZNetRequestModel.DownloadFile &amp;&amp; saveOrUploadFile != null &amp;&amp; saveOrUploadFile.exists() &amp;&amp; saveOrUploadFile.length() &gt; 0) &#123; return true; &#125; return false; &#125; /** * 处理文件下载响应 * @param response * @throws IOException */ @Override @WorkerThread public void handleResponse(@Nullable Response response, @NonNull ZZNetResponse netResponse)&#123; if (response == null)&#123; netResponse.errorType = ZZNetErrorType.NoResponse; netResponse.errorMsg = zzNet.getAppContext().getString(R.string.lib_network_net_msg6); return; &#125; if (response.code() == 416)&#123; LogUtils.w(zzNet.getUrl(), "文件已经下载完毕，不需要再次下载，终止本次请求"); netResponse.errorType = ZZNetErrorType.Success; return; &#125; if (!response.isSuccessful())&#123; return; &#125; // validator校验响应 ZZNetValidator appValidator = zzNet.getBuilder().getAppValidator(); if (appValidator != null)&#123; appValidator.isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); if (netResponse.errorType != ZZNetErrorType.Success)&#123; LogUtils.d(zzNet.getUrl(), "appValidator校验响应不通过，终止"); return; &#125; &#125; if (zzNet.getValidator() != null)&#123; zzNet.getValidator().isCorrectWithCallBackDataRunOnWorkThread(zzNet, netResponse); if (netResponse.errorType != ZZNetErrorType.Success)&#123; LogUtils.d(zzNet.getUrl(), "apiValidator校验响应不通过，终止"); return; &#125; &#125; boolean isSupportRange = isSupportRange(response); File saveOrUploadFile = zzNet.getSaveFile(); final boolean append = saveOrUploadFile.length() &gt; 0 &amp;&amp; isSupportRange; if (LogUtils.DEBUG)&#123; LogUtils.d(zzNet.getUrl(), "文件总大小", String.valueOf(response.body().contentLength()) , String.format("当前是否断点续传%s", Boolean.valueOf(append))); &#125; OutputStream os = null; try &#123; os = new FileOutputStream(saveOrUploadFile, append); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); try &#123; os.close(); &#125;catch (IOException ex)&#123; ex.printStackTrace(); &#125; return; &#125; InputStream is = response.body().byteStream(); boolean downloadSuccess = true; boolean isCanceled = false; try&#123; isCanceled = !copyStream(response.body().contentLength(), is, os, isSupportRange); &#125;catch (Exception e)&#123; e.printStackTrace(); downloadSuccess = false; &#125;finally &#123; try&#123; if (os != null)&#123; os.close(); &#125; if (is != null) &#123; is.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; if (isCanceled)&#123; // 被用户取消 netResponse.errorType = ZZNetErrorType.Canceled; &#125;else if (downloadSuccess)&#123; netResponse.errorType = ZZNetErrorType.Success; &#125; &#125; /** * 是否支持断点上传 * @param response * @return */ @WorkerThread public boolean isSupportRange(Response response) &#123; if (response == null || !zzNet.isSupportResumeDownload()) return false; if ("bytes".equals(response.header("Accept-Ranges"))) return true; String contentRanges = response.header("Content-Range"); if (contentRanges != null &amp;&amp; contentRanges.startsWith("bytes")) return true; return false; &#125; /** * 写数据到文件 * @param total * @param is * @param os * @return * @throws IOException */ @WorkerThread public boolean copyStream(long total, InputStream is, OutputStream os, boolean isSupportRange) throws IOException &#123; long current = 0; if (total &lt;= 0) &#123; total = is.available(); &#125; long oldFileCount = 0; File saveOrUploadFile = zzNet.getSaveFile(); if (isSupportRange &amp;&amp; saveOrUploadFile != null &amp;&amp; saveOrUploadFile.exists() &amp;&amp; saveOrUploadFile.length() &gt; 0) &#123; oldFileCount = saveOrUploadFile.length(); total += oldFileCount; &#125; final byte[] bytes = new byte[DEFAULT_BUFFER_SIZE]; int count; while ((count = is.read(bytes, 0, DEFAULT_BUFFER_SIZE)) != -1) &#123; if (zzNet.isCanceled())&#123; return false; &#125; os.write(bytes, 0, count); current += count; if (zzNet.getFileCallback() != null)&#123; ZZNetFileCallback callback = zzNet.getFileCallback().get(); if (callback != null)&#123; callback.onProgess(current + oldFileCount, total); &#125; &#125; &#125; return true; &#125;&#125; 自定义重试规则 允许请求失败后的重试操作，可以自定义重试规则，重试次数等。例如：客户端支付成功后需要查询支付状态，服务端的支付状态依赖第三方支付平台的通知，为降低通知延迟对客户端的影响，可以自定义重试规则，当支付失败时多重试几次。 重试机制规则抽象接口12345678910111213/** * 重试机制规则 */public interface ZZNetRetryRule &#123; /** * 是否需要重试，可在此定义重试规则，注意此函数是运行在工作线程中 * @param zzNetResponse * @return */ @WorkerThread boolean needRetry(ZZNetResponse zzNetResponse);&#125; 重试机制具体使用方法123456789101112131415161718192021222324252627282930313233/** * 自定义重试规则，App端支付成功后查询支付状态 * ，如果查询结果为支付失败，等待500ms后继续查询(最多3次)。 */public static class QueryPayStatusRetryRule implements ZZNetRetryRule &#123; // 该函数运行在工作线程中 @Override public boolean needRetry(ZZNetResponse response) &#123; // 可根据zzNetResponse定义重试规则 boolean needRetry = true; if (!TextUtils.isEmpty(response.rawString))&#123; try &#123; final JSONObject jsonObject = JSON.parseObject(response.rawString); if (jsonObject != null)&#123; final boolean paySuccess = jsonObject.getBooleanValue("xxx"); if (!paySuccess)&#123; if (LogUtils.DEBUG)&#123; LogUtils.w("支付失败，延迟500ms重新查询"); &#125; SystemClock.sleep(500); &#125;else&#123; // 支付成功, 不需要重试 needRetry = false; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return needRetry; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZAOZUO Android代码规范]]></title>
      <url>%2F2017%2F02%2F26%2Fandroid-developing-guideline%2F</url>
      <content type="text"><![CDATA[规范是提高团队开发协作效率的前提，请大家务必重视； 规范主要解决两个问题：1.提高协作效率；2.绕过已知的问题； 命名规范：Bundle命名规范： 工程名： 业务Bundle：biz_xxx Library Bundle：lib_xxx jar或aar Bundle：zzbin_xxx 包名： 业务Bundle：com.zaozuo.biz.xxx Library Bundle：com.zaozuo.lib.xxx 包名命名规范： com.zaozuo.[biz/lib].[模块名].[业务名] 123456com.zaozuo.biz.show.home entity ：实体类 presenter view：Activity/Fragment widget：自定义控件 viewholder：item/itemGroup 资源文件命名： 所有在R文件中生成资源文件必须添加模块前缀和业务前缀，规则：[业务模块名] _ [业务名] _ [具体名字]； 12345layout命名： activity/fragment对应的xml：biz_order_orderlist.xml item对应的xml：biz_order_orderlist_item_topview.xmldrawable命名： biz_order_orderlist_btn_camera.xml xml中id对应的控件名字采用缩写：[业务模块名字] _ [业务名] _ [按钮名字] _ [控件简称]； 12biz_order_orderlist_avatar_ivbiz_order_orderlist_confirm_btn style也需要添加前缀：例如Biz_Show_SplashTheme UI总线命名： UI总线url命名规则：[业务模块名] _ [业务名] _ [细分的业务名]； 1public static final String Biz_Order_OrderListActivity = "activity://biz_order/orderlist"; 消息总线命名： 消息总线，监听收到消息函数命名规则：onXXXEvent，例如：onLoginCompletedEvent 分类规范 同一个模块下资源文件一定要归类，例如string.xml按照业务放在一起； 书写规范： 每个函数，关键位置代码、成员变量添加Java标准注释； 每个类中同一业务逻辑，可使用分割线区分不同的代码块； 每次修改代码加修改说明、复杂逻辑添加实现思路； Bundle引入版本管理，每个Bundle中应该包含版本变化说明； 使用Android Support Annotations优化代码； @Nullable 修饰方法参数、返回值、成员变量，表示可能为空； @NonNull 修饰方法参数、返回值、成员变量，表示不会为空； @StringRes @ColorInt @IntDef @DrawableRes @LayoutRes 修饰资源id； @IntRange @FloatRange 限定参数范围； @CheckResult，必须处理返回值； @UiThread、@MainThread、@WorkerThread、@BinderThread，标识函数运行的线程； @CallSuper，必须调用super； 正确使用Java private protocted default public限定符； 所有内部类或接口必须使用static，防止内存泄露； 所有模块的BuildConfig都不要用，使用BuildInfo； 逻辑规范数据解析： JSON解析的代码必须try catch； 没有解析JSON的字段加上注解，@JSONField(deserialize = false)，并与参与JSON解析的字段分隔开； 使用fastjson解析基本数据类型，使用getXxxxValue()，不要使用getXx()，它是返回对象类型，如果返回为空，自动拆箱会崩溃； Entity： entity应该尽量精简，用不到的数据不要解析，结构层级不要纵向延伸； entity只处理简单的逻辑，注意过渡膨胀； 业务entity为减少方法数量，所有成员变量使用public修饰;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Activity生命周期和启动模式你不知道的那些事]]></title>
      <url>%2F2016%2F10%2F05%2Fandroid-activity-lifecycle-launchmode%2F</url>
      <content type="text"><![CDATA[此文是根据官方文档、图书资料及demo测试得出的结论，包括Activity多个页面间跳转的生命周期，各个启动模式的不同，flag的常见用法及对activity任务栈的影响。 Activity生命周期需要注意的地方 当Activity长时间在后台运行时，可能会被杀死，再次启动时Activity会被重建，此情况和横竖屏切换场景类似，开发者应该在开发环境下打开横竖屏切换测试，防止异常发生； 如果新的Activity是透明主题，则当前Activity不会执行onStop； onSaveInstanceState在onStop之前执行，onRestoreInstanceState在onStart之后执行； 为防止Activity横竖屏切换时Activity重启，可添加 android:configChanges=”orientation|screenSize” onStart和onStop，判断Activity是否可见，onResume和onPause，判断Activity是否在前台； A启动B，A、B生命周期执行顺序：A会先进入后台，B创建进入前台，A不可见； 1A(onPause) --&gt; B(onCreate) --&gt; B(onStart) --&gt; B(onResume) --&gt; A(onSaveInstanceState) -&gt;A(onStop) Activity启动模式Standard：标准模式 每次都会新创建Activity，并添加到对应的任务栈中； SingleTop：栈顶复用 如果要启动的Activity已经在栈顶，该Activity不会被创建； 123* A --&gt; B(SingleTop)* 再次启动B后生命周期：onPause --&gt; onNewIntent --&gt; onResume 如果要启动的Activity不在栈顶，跟标准模式完全一致； 123* A --&gt; B(SingleTop) --&gt; C* 再次启动B后栈：A --&gt; B(SingleTop) --&gt; C --&gt; B(SingleTop) SingleTask：栈内复用模式 特别注意，配置此模式的Activity并不会位于一个新的任务栈中，只是如果要启动的Activity已经在栈中，会clearTop，让自己置为栈顶； 1234567891011121314* A --&gt; B(SingleTask) --&gt; CTaskRecord&#123;ed93b47 #259 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=4&#125; Run #3: ActivityRecord&#123;c1f4817 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t259&#125; Run #2: ActivityRecord&#123;59e1a72 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t259&#125; Run #1: ActivityRecord&#123;d7ae33c u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t259&#125; * 再次启动B后任务栈：A --&gt; B(SingleTask)此时C会被销毁此时B的生命周期：onPause --&gt; onNewIntent --&gt; onResume TaskRecord&#123;ed93b47 #259 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #2: ActivityRecord&#123;59e1a72 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t259&#125; Run #1: ActivityRecord&#123;d7ae33c u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t259&#125; SingleInstance：单实例模式 此模式的Activity只能位于一个独立任务栈中； 1234567891011121314151617181920* A --&gt; B(SingleInstance) --&gt; C此时，A、C位于同一个任务栈，B位于独立的任务栈； TaskRecord&#123;c37f244 #253 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #3: ActivityRecord&#123;8d06468 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t253&#125;TaskRecord&#123;10b2e56 #257 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=1&#125; Run #2: ActivityRecord&#123;eeb0317 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t257&#125;TaskRecord&#123;c37f244 #253 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #1: ActivityRecord&#123;e25c532 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t253&#125; * 再次启动B后栈：A --&gt; C --&gt; B(SingleInstance)此时，B调整为前台任务栈，A、C的任务栈调整为后台任务栈；此时，B的生命周期：onPause --&gt; onNewIntent --&gt; onResumeTaskRecord&#123;10b2e56 #257 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=1&#125; Run #3: ActivityRecord&#123;eeb0317 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t257&#125;TaskRecord&#123;c37f244 #253 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #2: ActivityRecord&#123;8d06468 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t253&#125; Run #1: ActivityRecord&#123;e25c532 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t253&#125; 怎么确定Activity位于哪个任务栈 除SingleInstance模式的activity外，其它所有模式的activity都会被添加到默认的任务栈中，默认任务栈taskAffinity为包名； 可以通过指定taskAffinity让activity运行在特定的任务栈中，必须配合FLAG_ACTIVITY_NEW_TASK才会生效； 除SingleInstance模式的activity外，启动普通的activity都被添加到启动此activity所用的activity相同的任务栈中，除非同时指定taskAffinity和FLAG_ACTIVITY_NEW_TASK，会运行在与taskAffinity同名的任务栈中； 123456789101112* A --&gt; B(taskAffinity=test.gcoder.io.newtask flag=FLAG_ACTIVITY_NEW_TASK)TaskRecord&#123;99b9ba5 #269 A=test.gcoder.io.newtask, isShadow:false U=0 sz=1&#125; Run #2: ActivityRecord&#123;5ba0ca2 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t269&#125;TaskRecord&#123;ab040b2 #267 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=2&#125; Run #1: ActivityRecord&#123;1ddfc0 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t267&#125; * A --&gt; B(taskAffinity=test.gcoder.io.newtask flag=FLAG_ACTIVITY_NEW_TASK)--&gt; CTaskRecord&#123;99b9ba5 #269 A=test.gcoder.io.newtask, isShadow:false U=0 sz=2&#125; Run #3: ActivityRecord&#123;199ec49 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t269&#125; Run #2: ActivityRecord&#123;5ba0ca2 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t269&#125;TaskRecord&#123;ab040b2 #267 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=2&#125; Run #1: ActivityRecord&#123;1ddfc0 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t267&#125; Context对Activity任务栈的影响 经过对比，使用Activity Context启动与使用Application Context启动Activity无任何区别，都是在一个任务栈中; 使用Activity Context启动 12345678910* A --&gt; B(FLAG_ACTIVITY_NEW_TASK)TaskRecord&#123;6a79d7e #261 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #2: ActivityRecord&#123;8754172 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t261&#125; Run #1: ActivityRecord&#123;43b510 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t261&#125; * A --&gt; B(FLAG_ACTIVITY_NEW_TASK)--&gt;CTaskRecord&#123;6a79d7e #261 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=4&#125; Run #3: ActivityRecord&#123;4095453 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t261&#125; Run #2: ActivityRecord&#123;8754172 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t261&#125; Run #1: ActivityRecord&#123;43b510 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t261&#125; 使用Application Context启动 1234567891011121314151617* A --&gt; B(FLAG_ACTIVITY_NEW_TASK)TaskRecord&#123;eb6f24d #262 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #2: ActivityRecord&#123;215a79a u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t262&#125; Run #1: ActivityRecord&#123;7e22051 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t262&#125; * A --&gt; B(FLAG_ACTIVITY_NEW_TASK)--&gt; C TaskRecord&#123;eb6f24d #262 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=4&#125; Run #3: ActivityRecord&#123;dac68e6 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t262&#125; Run #2: ActivityRecord&#123;215a79a u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t262&#125; Run #1: ActivityRecord&#123;7e22051 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t262&#125; * 再次启动B后：A --&gt; B(FLAG_ACTIVITY_NEW_TASK) --&gt; C --&gt; B(FLAG_ACTIVITY_NEW_TASK) TaskRecord&#123;eb6f24d #262 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=5&#125; Run #4: ActivityRecord&#123;2ec8ea1 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t262&#125; Run #3: ActivityRecord&#123;c30b233 u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t262&#125; Run #2: ActivityRecord&#123;e88653e u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t262&#125; Run #1: ActivityRecord&#123;177c4a8 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t262&#125; Flag对Activity任务栈的影响FLAG_ACTIVITY_NEW_TASK 只添加此Flag的Activity不会被添加新的任务栈中，此时跟SingleTask无任何关系，也不具备SingleTask同一个任务栈中唯一的特性及clearTop的特性； 此Flag可被用于非Activity类型的Context启动新Activity； 此Flag与其它Flag混合使用会有不同的效果； FLAG_ACTIVITY_MULTIPLE_TASK 此Flag一般不单独使用，需要配合FLAG_ACTIVITY_NEW_TASK使用； FLAG_ACTIVITY_MULTIPLE_TASK | FLAG_ACTIVITY_NEW_TASK 单独使用时，会检索已经存在的任务栈，如果启动的activity对应的任务栈存在就不会创建，不存在才会创建新的任务栈； 同时使用时，会强制创建新的任务栈，并将启动的activity放在新的任务栈中， 后续使用此activity启动的标准模式的activity会运行在此栈中，而不是默认栈中； 123456789101112131415161718192021* A --&gt; B(FLAG_ACTIVITY_MULTIPLE_TASK|FLAG_ACTIVITY_NEW_TASK)TaskRecord&#123;4144b1a0 #6 A test.gcoder.io.testactivity U 0&#125; Run #3: ActivityRecord&#123;413fd7a8 test.gcoder.io.testactivity/.BActivity&#125;TaskRecord&#123;41548560 #5 A test.gcoder.io.testactivity U 0&#125; Run #2: ActivityRecord&#123;41562330 test.gcoder.io.testactivity/.AActivity&#125; * A --&gt; B(FLAG_ACTIVITY_MULTIPLE_TASK|FLAG_ACTIVITY_NEW_TASK) --&gt; CTaskRecord&#123;4144b1a0 #6 A test.gcoder.io.testactivity U 0&#125; Run #4: ActivityRecord&#123;41604278 test.gcoder.io.testactivity/.CActivity&#125; Run #3: ActivityRecord&#123;413fd7a8 test.gcoder.io.testactivity/.BActivity&#125;TaskRecord&#123;41548560 #5 A test.gcoder.io.testactivity U 0&#125; Run #2: ActivityRecord&#123;41562330 test.gcoder.io.testactivity/.AActivity&#125; * A --&gt; B(FLAG_ACTIVITY_MULTIPLE_TASK|FLAG_ACTIVITY_NEW_TASK) --&gt; C --&gt; B(FLAG_ACTIVITY_MULTIPLE_TASK|FLAG_ACTIVITY_NEW_TASK)TaskRecord&#123;41434a90 #7 A test.gcoder.io.testactivity U 0&#125; Run #5: ActivityRecord&#123;413a6710 test.gcoder.io.testactivity/.BActivity&#125;TaskRecord&#123;4144b1a0 #6 A test.gcoder.io.testactivity U 0&#125; Run #4: ActivityRecord&#123;41604278 test.gcoder.io.testactivity/.CActivity&#125; Run #3: ActivityRecord&#123;413fd7a8 test.gcoder.io.testactivity/.BActivity&#125;TaskRecord&#123;41548560 #5 A test.gcoder.io.testactivity U 0&#125; Run #2: ActivityRecord&#123;41562330 test.gcoder.io.testactivity/.AActivity&#125; FLAG_ACTIVITY_SINGLE_TOP 同SingleTop FLAG_ACTIVITY_CLEAR_TOP 此Flag单独使用时，如果启动的Activity存在对应的任务栈中，只是会清除任务栈中要启动的Activity之上所有的Activity，要启动的Activity会先销毁后重新创建； 此Flag单独使用时，如果启动的Activity不存在对应的任务栈中，则创建并添加到对应的任务栈中； 123456789101112131415* A --&gt; B(FLAG_ACTIVITY_CLEAR_TOP) --&gt; CTaskRecord&#123;166703a #289 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=4&#125; Run #3: ActivityRecord&#123;374b0ff u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t289&#125; Run #2: ActivityRecord&#123;15086 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t289&#125; Run #1: ActivityRecord&#123;da843b0 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t289&#125; * 再次启动B(FLAG_ACTIVITY_CLEAR_TOP)* 生命周期：C会销毁，B会先销毁后创建C(onPause)B(onDestroy)--&gt;B(onCreate)--&gt;B(onStart)--&gt;B(onResume)C(onStop)--&gt;C(onDestroy) TaskRecord&#123;166703a #289 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=3&#125; Run #2: ActivityRecord&#123;6420128 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t289&#125; Run #1: ActivityRecord&#123;da843b0 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t289&#125; FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_NEW_TASK 如果要启动的Activity在对应的任务栈中，则会销毁任务栈顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例； 如果启动的Activity没有在对应的任务栈中，则创建新的任务栈，创建Activity并添加到新的任务栈中； 1234567891011121314151617181920212223* A --&gt; B（FLAG_ACTIVITY_MULTIPLE_TASK | FLAG_ACTIVITY_CLEAR_TOP）TaskRecord&#123;413377c #286 A=test.gcoder.io.newtask, isShadow:false U=0 sz=1&#125; Run #2: ActivityRecord&#123;a58be9a u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t286&#125;TaskRecord&#123;cfe9805 #285 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=2&#125; Run #1: ActivityRecord&#123;b5a1c24 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t285&#125; * A --&gt; B（FLAG_ACTIVITY_MULTIPLE_TASK | FLAG_ACTIVITY_CLEAR_TOP）--&gt; CTaskRecord&#123;413377c #286 A=test.gcoder.io.newtask, isShadow:false U=0 sz=2&#125; Run #3: ActivityRecord&#123;9f7c8df u0 test.gcoder.io.testactivity/.CActivity, isShadow:false t286&#125; Run #2: ActivityRecord&#123;a58be9a u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t286&#125;TaskRecord&#123;cfe9805 #285 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=2&#125; Run #1: ActivityRecord&#123;b5a1c24 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t285&#125; * 再次启动B（FLAG_ACTIVITY_MULTIPLE_TASK | FLAG_ACTIVITY_CLEAR_TOP）* 生命周期：C会销毁，B会先销毁后创建C(onPause)B(onDestroy)--&gt;B(onCreate)--&gt;B(onStart)--&gt;B(onResume)C(onStop)--&gt;C(onDestroy) TaskRecord&#123;413377c #286 A=test.gcoder.io.newtask, isShadow:false U=0 sz=1&#125; Run #2: ActivityRecord&#123;ff16c57 u0 test.gcoder.io.testactivity/.BActivity, isShadow:false t286&#125;TaskRecord&#123;cfe9805 #285 A=test.gcoder.io.testactivity, isShadow:false U=0 sz=2&#125; Run #1: ActivityRecord&#123;b5a1c24 u0 test.gcoder.io.testactivity/.AActivity, isShadow:false t285&#125; 注：如果指定 Activity 的启动模式为 “standard”，则该 Activity 也会从堆栈中移除，并在其位置启动一个新实例，以便处理传入的 Intent。 这是因为当启动模式为 “standard” 时，将始终为新 Intent 创建新实例。 参考资料： Android开发艺术探索第一章； Android官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android HotPatch在线热补丁方案]]></title>
      <url>%2F2015%2F08%2F12%2Fandroid-hotpatch-dexposed%2F</url>
      <content type="text"><![CDATA[本教程采用阿里dexposed开源库实现。https://github.com/alibaba/dexposed 主APP实现：主程序Application onCreate方法中初始化dexposed1DexposedBridge.canDexposed(context); Patch apk下载及修复： 为保证修复patch的及时性，使用push推送patch，客户端收到消息后立即完成patch的下载及修复； 客户端版本管理模块在程序入口Activity中检测是否有需要修复的patch； 下载完patch apk到程序私有目录，即/data/data/packageName/files目录，同时可在xml中保存patch apk本地存储路径、方便下载启动app时加载补丁patch。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class HotPatchManager &#123;public static boolean canDexposed = false;private static final String SP_KEY_HOT_PATCH = "hot_patch_path"; /** * init hotPatch library. * * @param Context */ public static void init(Context context) &#123; // aop init. canDexposed = DexposedBridge.canDexposed(context); if (canDexposed) &#123; List&lt;String&gt; list = getHotPatchPaths(context); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (String path : list) &#123; runPatchApk(context, path); &#125; &#125; &#125; else &#123; if (LogUtils.DEBUG) &#123; LogUtils.d("==========your device not support dexposed aop.=========="); &#125; &#125; &#125; /** * /data/data/package/files * * @param context * @param apkPath */ public static void runPatchApk(Context context, String apkPath) &#123; if (Build.VERSION.SDK_INT &gt;= 21 || !canDexposed) &#123; LogUtils.d("This device doesn't support dexposed."); return; &#125; if (!pathIsValid(context, apkPath)) &#123; return; &#125; try &#123; PatchResult result = PatchMain.load(context, apkPath, null); if (result.isSuccess()) &#123; LogUtils.d("hotPath load apk success."); &#125; else &#123; LogUtils.e("hotPath load apk error.", result.getErrorInfo()); result.getThrowbale().printStackTrace(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * download hotPatch and auto mege. * * @param context */ public static void downloadHotPatch(final Context context, String downloadUrl) &#123; if (TextUtils.isEmpty(downloadUrl)) &#123; LogUtils.d("downloadUrl is null."); return; &#125; DownloadInfo downloadInfo = new DownloadInfo(); downloadInfo.setDownloadUrl(downloadUrl); String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1); String fileSavePath = new File(context.getFilesDir(), fileName).getAbsolutePath(); downloadInfo.setFileSavePath(fileSavePath); downloadInfo.setDaoCallback( new Task.Callback() &#123; @Override public void onSuccess(DownloadInfo downloadInfo) &#123; LogUtils.d("runPatchApk begin.", downloadInfo.getFileSavePath()); runPatchApk(context, downloadInfo.getFileSavePath()); appendHotPatchPath(context, downloadInfo.getFileSavePath()); LogUtils.d("runPatchApk end.", downloadInfo.getFileSavePath()); &#125; @Override public void onStart(DownloadInfo downloadInfo) &#123; &#125; @Override public void onFailure(DownloadInfo downloadInfo) &#123; &#125; @Override public boolean onLoading(long total, long current) &#123; return true; &#125; @Override public void onCancelled(DownloadInfo downloadInfo) &#123; &#125; &#125; ); DownloadManager dm = DownloadService.getDownloadManager(context, DownloadService.ACTION); dm.addDownloadTask(downloadInfo); &#125; public static void clearHotPatchFiles(Context context) &#123; List&lt;String&gt; list = getHotPatchPaths(context); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (String path : list) &#123; FileUtils.delFile(path); &#125; &#125; &#125; public static boolean pathIsValid(Context context, String apkPath) &#123; if (TextUtils.isEmpty(apkPath)) &#123; LogUtils.d("apkPath is null."); return false; &#125; String parentDir = String.format("/data/data/%s/files", context.getPackageName()); File apkFile = new File(apkPath); if (!parentDir.equals(apkFile.getParent())) &#123; LogUtils.d("apkPath is error.", apkPath); return false; &#125; if (!apkFile.exists())&#123; LogUtils.d("apkPath is not exist.", apkPath); return false; &#125; return true; &#125; public static List&lt;String&gt; getHotPatchPaths(Context context) &#123; List&lt;String&gt; list = null; SP sp = SP.getInstance(context); String paths = sp.getString(SP_KEY_HOT_PATCH, null); if (!TextUtils.isEmpty(paths)) &#123; if (paths.indexOf(",") != -1) &#123; String[] pathArr = paths.split(","); if (pathArr != null &amp;&amp; pathArr.length &gt; 0) &#123; list = Arrays.asList(paths); &#125; &#125; else &#123; list = new ArrayList&lt;String&gt;(); list.add(paths); &#125; &#125; return list; &#125; public static void appendHotPatchPath(Context context, String apkPath) &#123; if (!pathIsValid(context, apkPath)) &#123; return; &#125; SP sp = SP.getInstance(context); String paths = sp.getString(SP_KEY_HOT_PATCH, null); if (!TextUtils.isEmpty(paths)) &#123; String allPath = new StringBuilder(apkPath).append(",").append(apkPath).toString(); sp.commit(SP_KEY_HOT_PATCH, allPath); &#125; else &#123; sp.commit(SP_KEY_HOT_PATCH, apkPath); &#125; &#125; public static void clearHotPatchPaths(Context context) &#123; SP sp = SP.getInstance(context); sp.commit(SP_KEY_HOT_PATCH, ""); &#125;&#125; Patch Apk部分： dexpose支持方法粒度的patch，可以实现整个方法的替换或方法前、后执行修复代码。以下实例为方法替换实例，其它只需实现相应的回调接口即可。 方法替换实例： 新建Android工程，引入patchloader.jar、dexposedbridge.jar； 创建Patch修复类实现IPatch接口； 123456789101112131415161718192021222324public class HotPatch implements IPatch &#123; @Override public void handlePatch(final PatchParam arg0) throws Throwable &#123; Class&lt;?&gt; cls = null; try &#123; cls= arg0.context.getClassLoader() .loadClass("com.zaozuo.app.MainActivity"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return; &#125; DexposedBridge.findAndHookMethod(cls, "bindData", new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; Activity mainActivity = (Activity) param.thisObject; Toast.makeText(mainActivity, "test show hotPatch.",Toast.LENGTH_LONG).show(); return null; &#125; &#125;); &#125;&#125; 打包patch apk，上传到服务器并通知客户端下载。 Patch Apk安全性： 打包apk必须使用主app签名文件签名； 主app对加载的patch apk做签名和无篡改校验：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Swift开发中需要注意的问题]]></title>
      <url>%2F2015%2F07%2F25%2Fios-swift-dev-remind%2F</url>
      <content type="text"><![CDATA[普通block和lazy底层是闭包，必须注意self指针泄露，解决方案同block： 123private lazy var oneButtonView : OneButtonView? = &#123;[weak self] in return self?.instanceOneButtonView()&#125;() 判断字符串相等时必须先校验是否为nil，否则崩溃 12if name != nil &amp;&amp; name == "UserName"&#123;&#125; 超级坑，View的名字不可于VC相似 例如：BuyPresellView BuyPresellViewController，会造成BuyPresellViewController自动从BuyPresellView.xib加载； UITextLabel text设置为nil或””时该控件的高度为0，如果想正常显示可设为” “ 可选值不可与非可选值进行比较，例如String?和String，必须转换为相同类型才可比较mobile != nil &amp;&amp; mobile! == text，注意判断非空； 点击事件触发网络操作，需要用到index时，可使用id替换，防止非阻塞对话框导致用户继续操作，造成index改变； 所有涉及到数组、集合index取值、删除等操作必须校验Index范围保证不会越界； switch中case必须加break，避免养成习惯在其它编程语言中造成问题； 禁止在layoutSubviews编写任何AutoLayout代码，会造成在iOS7.X崩溃； 字符串拼接的时候，如果是可选型必须强制转换，否则string会带Optional字符串； 系统api重写时必须调用super； 添加NSNotification监听的类必须是NSObject的子类，并且响应函数不能使用private修饰，否则崩溃； Objective-C属性或者方法如果不加Nullability属性的话，则默认为隐式可 选类型。应该声明为可选类型防止空值时造成崩溃； 如下图所示，AFN成功失败的block中参数应该声明为可选型 12345678910NetworkUtils.getManager().POST("", parameters: nil , success: &#123; (operation: AFHTTPRequestOperation?, response:AnyObject?) in if response != nil&#123; &#125; &#125;) &#123; (operation: AFHTTPRequestOperation?, error:NSError?) in if error != nil&#123; &#125; &#125; 为了和 Objective-C 协同工作，很多 Swift 标准库类型和对应的 Cocoa 类型是可以隐式的类型转换的，比如 Swift.Array 与 NSArray， Swift.String 和 NSString 等，类型转换有较大的性能开销，应该避免或减 少类型转换，尽量使用Swift提供的数据类型； 使用通知，如果是一对一的情况，必须使用EventMsg中标识的唯一时间戳 校验，防止出现多个页面时，多个页面都收到通知； 1234567891011121314151617// 发送一对一广播let scrollType = UICollectionViewDelegateForNavBar.SCROLL_TYPE_DOWNlet eventMsg = EventMsg(targetEventTime: targetEventTime, object: scrollType)NSNotificationCenter.defaultCenter().postNotificationName(UICollectionViewDelegateForNavBar.NOTI_NAME_NAVBAR_SCROLL, object: eventMsg) // 处理接收到的广播func onNavBarViewScrollNotification(noti:NSNotification)&#123; if supportNavbarScroll&#123; if let eventMsg = noti.object as? EventMsg&#123; if eventMsg.targetEventTime == nil || eventMsg.targetEventTime != eventTime&#123; return &#125; if let scrollType = eventMsg.object as? Int&#123; navBarViewScrollToTop(scrollType) &#125; &#125; &#125;&#125; 对于一次性的vc addsubview，用完之后调用以下函数，不要调用 self.view.hide = true，应该将该完全销毁，可以使用vc扩张中添加的函数 12345678910111213141516171819202122232425262728293031323334// 添加ViewControllerfunc zzAddChildViewController(childVC: UIViewController, anim: Bool = true)&#123; self.view.addSubview(childVC.view) self.addChildViewController(childVC) childVC.didMoveToParentViewController(self) // anim if anim&#123; childVC.view.alpha = 0.0 UIView.animateWithDuration(0.3, animations: &#123;() -&gt; Void in childVC.view.alpha = 1.0 &#125;) &#123; (finished) -&gt; Void in &#125; &#125;&#125; // 删除ViewControllerfunc zzRemoveFromParentViewController(anim: Bool = true)&#123; if anim&#123; UIView.animateWithDuration(0.3, animations: &#123;[weak self] () -&gt; Void in self?.view.alpha = 0.0 &#125;) &#123;[weak self] (finished) -&gt; Void in self?.view.hidden = true self?.willMoveToParentViewController(nil) self?.view.removeFromSuperview() self?.removeFromParentViewController() &#125; &#125;else&#123; self.view.hidden = true self.willMoveToParentViewController(nil) self.view.removeFromSuperview() self.removeFromParentViewController() &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 数据库模块搭建方案]]></title>
      <url>%2F2015%2F07%2F19%2Fios-db-plan%2F</url>
      <content type="text"><![CDATA[数据库作为App缓存设计的首选，存在一些开发的陷阱，同时需要考虑性能、开发效率和可维护性，笔者建议自行搭建数据库管理类，同时配合成熟的开源ORM框架快速搭建数据库模块。本示例采用fmdb框架 https://github.com/ccgus/fmdb SQLite多线程访问问题分析：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void) testfmdb&#123; // db path NSString * cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0]; NSString * dbPath = [cachePath stringByAppendingPathComponent:@"test.sqlite"]; // create db _db = [FMDatabase databaseWithPath:dbPath]; // open db BOOL openDbResult = [_db open]; NSLog(@"openDbResult===%@", openDbResult ? @"YES":@"NO"); // create table BOOL createTableResult = [_db executeUpdate:@"create table if not exists user(id integer primary key autoincrement, name text, age integer)"]; NSLog(@"createTableResult===%@", createTableResult ? @"YES":@"NO"); // test multithreading NSOperationQueue *myQueue = [[NSOperationQueue alloc] init]; [myQueue setMaxConcurrentOperationCount:10]; for (int i = 0; i &lt; 100; i ++) &#123; NSBlockOperation *opBlock = [NSBlockOperation blockOperationWithBlock:^&#123; [self insert]; [self query]; &#125;]; [myQueue addOperation:opBlock]; &#125; &#125;-(void) insert&#123; for (int i = 0; i &lt; 100; i ++) &#123; NSString *name = [NSString stringWithFormat:@"name_%d",i]; NSString *age = [NSString stringWithFormat:@"%d",i]; [_db executeUpdate:@"insert into user(name,age) values (?, ?)", name,age]; &#125;&#125;-(void) query&#123; FMResultSet * set = [_db executeQuery:@"select * from user"]; while ([set next]) &#123; int id = [set intForColumn:@"id"]; NSString *name = [set stringForColumn:@"name"]; int age = [set intForColumn:@"age"]; NSLog(@"%d===%@===%d", id, name, age); &#125;&#125; 调用testfmdb方法抛出异常：The FMDatabase is currently in use. ios中SQLite同Android中SQLite一样，数据库不支持多线程读写并发访问，Android底层对SQLite单个数据库连接读写操作做了同步处理，也仅能支持单数据库连接的并发访问。 SQLite多线程访问解决方案：使用fmdb FMDatabaseQueue FMDatabaseQueue对所有数据库访问都在串行同步队列中执行，规避并发问题的产生； 所有数据库的操作，通过调用 inDatabase 在block回调中通过db访问数据库，block代码在当前线程中执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-(void) testfmdb_queue&#123; // db path NSString * cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0]; NSString * dbPath = [cachePath stringByAppendingPathComponent:@"test.sqlite"]; // create db and open db _queue = [FMDatabaseQueue databaseQueueWithPath:dbPath]; // create table [_queue inDatabase:^(FMDatabase *db) &#123; BOOL createTableResult = [_db executeUpdate:@"create table if not exists user(id integer primary key autoincrement, name text, age integer)"]; NSLog(@"createTableResult===%@", createTableResult ? @"YES":@"NO"); &#125;]; // test multithreading NSOperationQueue *myQueue = [[NSOperationQueue alloc] init]; [myQueue setMaxConcurrentOperationCount:10];//设置并发线程数量. for (int i = 0; i &lt; 20; i ++) &#123; NSBlockOperation *opBlock = [NSBlockOperation blockOperationWithBlock:^&#123; [self insert_queue]; [self query_queue]; &#125;]; [myQueue addOperation:opBlock]; &#125;&#125;-(void) insert_queue&#123; [_queue inDatabase:^(FMDatabase *db) &#123; for (int i = 0; i &lt; 20; i ++) &#123; NSString *name = [NSString stringWithFormat:@"name_%d",i]; NSString *age = [NSString stringWithFormat:@"%d",i]; [db executeUpdate:@"insert into user(name,age) values (?, ?)", name,age]; &#125; &#125;]; &#125;-(void) query_queue&#123; [_queue inDatabase:^(FMDatabase *db) &#123; FMResultSet * set = [db executeQuery:@"select * from user"]; while ([set next]) &#123; int id = [set intForColumn:@"id"]; NSString *name = [set stringForColumn:@"name"]; int age = [set intForColumn:@"age"]; NSLog(@"%d===%@===%d", id, name, age); &#125; &#125;];&#125; 配合fmdb快速搭建ORM： 定义DAO基类ZZBaseDAO； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;#import "FMDatabase.h"#import "FMDatabaseQueue.h"@interface ZZBaseDAO : NSObject@property(nonatomic,retain) FMDatabaseQueue * queue;@property(nonatomic,copy) NSString * dbPath;/** 初始化数据库 @params newDBPath 数据库完整路径 **/-(id) initWithDBPath:(NSString *) newDBPath;/** 获取数据库路径 @params dbName 数据库名 **/- (NSString *) generateFilePath: (NSString *) dbName;/** 字典对象转为实体对象 @params dict @params entity 实体数据，传入前需要创建好 **/+ (void) dictionaryToEntity:(NSDictionary *)dict entity:(NSObject*)entity;/** 实体对象转为字典对象，不支持对象中包含c基本数据类型，如：int、float等。 @params entity **/+ (NSDictionary *) entityToDictionary:(id)entity;/** fmdb查询结果集转为实体对象数组 @params set fmdb查询结果集 @params clazz 实体数据，传入前需要创建好 **/+ (NSMutableArray *) dictionaryToEntityList:(FMResultSet *)set entity:(Class)clazz;/** fmdb查询结果集转为实体对象数组，适用于查询结果为单条记录的情况 @params set fmdb查询结果集 @params clazz 实体数据，传入前需要创建好 **/+ (id) dictionaryToEntityOne:(FMResultSet *)set entity:(Class)clazz;@end ZZBaseDAO实现类，通过调用NSObject的setValuesForKeysWithDictionary和valueForKey实现NSDictionary和entity对象间转换； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#import "ZZBaseDAO.h"#import "Constants.h"#import &lt;objc/runtime.h&gt;@implementation ZZBaseDAO@synthesize queue, dbPath;-(id) init&#123; self = [super init]; if (self) &#123; dbPath = [self generateFilePath:DB_NAME_DEFAULT]; queue = [FMDatabaseQueue databaseQueueWithPath: dbPath]; &#125; return self;&#125;-(id) initWithDBPath:(NSString *) newDBPath&#123; self = [super init]; if (self) &#123; // create db and open db dbPath = newDBPath; queue = [FMDatabaseQueue databaseQueueWithPath:newDBPath]; &#125; return self;&#125;- (NSString *) generateFilePath: (NSString *) dbName&#123; // db path NSString * cachePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0]; NSString * newDBPath = [cachePath stringByAppendingPathComponent:dbName]; return newDBPath;&#125;+ (void) dictionaryToEntity:(NSDictionary *)dict entity:(NSObject*)entity&#123; if (dict &amp;&amp; entity) &#123; [entity setValuesForKeysWithDictionary:dict]; &#125;&#125;+ (NSDictionary *) entityToDictionary:(id)entity&#123; u_int count; objc_property_t* properties = class_copyPropertyList([entity class], &amp;count); NSMutableArray* propertyArray = [NSMutableArray array]; NSMutableArray* valueArray = [NSMutableArray array]; for (int i = 0; i &lt; count; i++)&#123; // propertyNameStr objc_property_t prop = properties[i]; const char* propertyName = property_getName(prop); NSString *propertyNameStr = [NSString stringWithUTF8String:propertyName]; id value = [entity valueForKey:propertyNameStr]; if(value != nil)&#123; // propertyArray [propertyArray addObject:propertyNameStr]; // valueArray [valueArray addObject:value]; &#125; &#125; free(properties); // entity -&gt; dict NSDictionary* returnDic = [NSDictionary dictionaryWithObjects:valueArray forKeys:propertyArray]; return returnDic;&#125;+ (NSMutableArray *) dictionaryToEntityList:(FMResultSet *)set entity:(Class)clazz&#123; if (set &amp;&amp; clazz) &#123; NSMutableArray * arr = [NSMutableArray array]; while ([set next]) &#123; NSDictionary *dic = [set resultDictionary]; id entity = [[clazz alloc]init]; [ZZBaseDAO dictionaryToEntity:dic entity:entity]; [arr addObject:entity]; &#125; return arr; &#125; return nil;&#125;+ (id) dictionaryToEntityOne:(FMResultSet *)set entity:(Class)clazz&#123; if (set &amp;&amp; clazz) &#123; [set next]; NSDictionary *dic = [set resultDictionary]; id entity = [[clazz alloc]init]; [ZZBaseDAO dictionaryToEntity:dic entity:entity]; return entity; &#125; return nil;&#125;@end fmdb数据库操作ORM实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void) testfmdb_queue&#123; _queue = [self getFMDatabaseQueue]; // create table [_queue inDatabase:^(FMDatabase *db) &#123; BOOL createTableResult = [_db executeUpdate:@"create table if not exists user(id integer primary key autoincrement, name text, age integer)"]; NSLog(@"createTableResult===%@", createTableResult ? @"YES":@"NO"); &#125;]; // test multithreading NSOperationQueue *myQueue = [[NSOperationQueue alloc] init]; [myQueue setMaxConcurrentOperationCount:10];//设置并发线程数量. for (int i = 0; i &lt; 1; i ++) &#123; NSBlockOperation *opBlock = [NSBlockOperation blockOperationWithBlock:^&#123; [self insert_queue]; [self query_queue]; &#125;]; [myQueue addOperation:opBlock]; &#125;&#125;-(void) insert_queue&#123; [_queue inDatabase:^(FMDatabase *db) &#123; for (NSInteger i = 0; i &lt; 20; i ++) &#123; TestUser *user = [[TestUser alloc]init]; user.name = [NSString stringWithFormat:@"test_name_%ld",i]; user.age = i; NSDictionary *dic = [ZZBaseDAO entityToDictionary:user]; NSLog(@"dic===%@", dic); BOOL insertResult = [db executeUpdate:@"insert into user(name,age) values (:name, :age)" withParameterDictionary:dic]; NSLog(@"insertResult===%@", insertResult?@"YES":@"NO"); &#125; &#125;]; &#125;-(void) query_queue&#123; [_queue inDatabase:^(FMDatabase *db) &#123; FMResultSet *set = nil; @try &#123; set = [db executeQuery:@"select id,name,age from user limit 10"]; NSMutableArray *arr = [ZZBaseDAO dictionaryToEntityList:set entity:[TestUser class]]; if (arr) &#123; for (TestUser* user in arr) &#123; NSLog(@"%ld===%@===%ld", user.pid, user.name, (long)user.age); &#125; &#125; &#125; @catch (NSException *exception) &#123; &#125; @finally &#123; if (set) &#123; [set close]; &#125; &#125; &#125;];&#125; 处理数据库中特殊字段如id等与oc关键字冲突的情况：定义函数setValue:forUndefinedKey，实现特殊数据库字段与entity中property的映射。 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface ZZBaseEntity : NSObject- (void) setValue:(id)value forUndefinedKey:(NSString *)key;@end#import "ZZBaseEntity.h"@implementation ZZBaseEntity- (void) setValue:(id)value forUndefinedKey:(NSString *)key&#123;// if ([key isEqualToString:@"id"]) &#123;// self.pid = [value integerValue];// &#125;&#125;@end 使用fmdb升级数据库：通过判断表中字段是否存在来确定是否需要升级 123456789// create db and open db_queue = [FMDatabaseQueue databaseQueueWithPath:dbPath];[_queue inDatabase:^(FMDatabase *db) &#123; // 判断数据库字段是否存在,需要#import"FMDatabaseAdditions.h" BOOL exist = [db columnExists:@"name" inTableWithName:@"user"]; NSLog(@"exist===%@", exist?@"YES":@"NO"); &#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 多线程]]></title>
      <url>%2F2015%2F06%2F12%2Fios-base-thread%2F</url>
      <content type="text"><![CDATA[NSThread 使用NSThread对象建立一个线程非常方便，但要使用NSThread管理多个线程较困难,不推荐使用; [NSThread currentThread]跟踪任务所在线程,适用于这三种技术。 1234567891011121314- (void) testNSThread&#123; // 创建方法1 [NSThread detachNewThreadSelector:@selector(actionForNSThread:) toTarget:self withObject:@"1"]; // 创建方法2 NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(actionForNSThread:) object:@"1"]; [thread start];&#125;- (void) actionForNSThread:(NSString *)extraData&#123; @autoreleasepool&#123; NSLog(@"actionForNSThread===%@", extraData); &#125;&#125; NSObjectNSObject的多线程方法： 开启后台执行任务的方法: 1- (void)performSelectorInBackground:(SEL)@Selector withObject:(id)arg 在后台线程中通知主线程执行任务的方法: 1- (void)performSelectorOnMainThread:(SEL)@Selector withObject:(id)arg waitUntilDone:(BOOL)wait NSObject的多线程方法注意事项: NSObject的多线程方法使用的是NSThread的多线程技术. NSThread的多线程技术不会自动使用@autoreleasepool. 在使用NSObject或NSThread的多线程技术时,如果涉及到对象分配,需要手动添加@autoreleasepool. NSOperationQueue 支持线程池，可配置并发线程最大数量； 可设置线程间依赖关系，即在特定线程执行完毕后执行该线程； 12345678910111213141516171819202122- (void) testNSOperationQueue&#123; // queue NSOperationQueue *myQueue = [[NSOperationQueue alloc] init]; [myQueue setMaxConcurrentOperationCount:1];//设置并发线程数量. // function operation NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationAction:) object:@(1)]; // block operation NSBlockOperation *opBlock = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"NSBlockOperation----%@----obj",[NSThread currentThread]); &#125;]; [op addDependency:opBlock];//设置依赖关系（先后执行顺序）. [myQueue addOperation:op]; [myQueue addOperation:opBlock];&#125;-(void)operationAction:(id)obj&#123; NSLog(@"NSInvocationOperation----%@----obj : %@ ",[NSThread currentThread], obj);&#125;; 线程同步NSLock123NSLock *lock = [[NSLock alloc]init];[lock lock];// 加锁[lock unlock];// 解锁 @synchronized同步代码块，将原子操作的代码放在synchronized中间。 12@synchronized(self)&#123; &#125; NSCondition条件锁，除支持lock和unlock外，还支持暂停或恢复线程。 12345NSCondition *con = [[NSCondition alloc]init];[con lock];// 加锁[con unlock];// 解锁[con wait]; // 暂停当前线程[con signal]; // 恢复当前线程 NSRecursiveLock：递归锁，针对递归 NSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。 pthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 数据存储方式]]></title>
      <url>%2F2015%2F06%2F09%2Fios-base-io%2F</url>
      <content type="text"><![CDATA[Plist(NSArray/NSDictionary)： 支持的数据类型有NSString、 NSNumber、NSDate、 NSArray、NSDictionary、BOOL、NSInteger、NSFloat等系统定义的数据类型，底层是基于key-value的NSDictionary。 项目中预置的plist文件只能读取不支持修改、删除； 运行期创建的plist文件支持读取、新写入、修改、删除等操作，写入时必须是完整的dic，不支持增量写入方式。 读取项目中预置plist文件：12345- (void) testPlist&#123; NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"test" ofType:@"plist"]; NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath]; NSLog(@"data===%@", data);&#125; 运行期创建的plist文件读取数据：123456789- (void) testReadPlist&#123; // 存储路径 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath = [paths objectAtIndex:0]; NSString *filename=[plistPath stringByAppendingPathComponent:@"test_new.plist"]; // 查询 NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:filename]; NSLog(@"%@", data);&#125; 运行期创建新plist并写入数据：12345678910111213141516171819- (void) testWriteNewPlist&#123; // 存储路径 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath = [paths objectAtIndex:0]; NSString *filename=[plistPath stringByAppendingPathComponent:@"test_new.plist"]; // 原始数据 NSMutableDictionary *data = [NSMutableDictionary dictionary]; // key存在value被覆盖，key不存在新增 [data setObject:@(1) forKey:@"age"]; // 写入数据 BOOL success = [data writeToFile:filename atomically:YES]; NSLog(@"success===%@", success?@"YES":@"NO"); // 查询验证结果 NSMutableDictionary *data1 = [[NSMutableDictionary alloc] initWithContentsOfFile:filename]; NSLog(@"%@", data1);&#125; 运行期创建的plist修改、删除数据：12345678910111213141516171819202122- (void) testModifyAndRemovePlist&#123; // 存储路径 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath = [paths objectAtIndex:0]; NSString *filename=[plistPath stringByAppendingPathComponent:@"test_new.plist"]; NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:filename]; NSLog(@"%@", data); // 修改数据 [data setObject:@(2) forKey:@"age"]; // 删除数据 [data removeObjectForKey:@"name"]; // 写入数据 BOOL success = [data writeToFile:filename atomically:YES]; NSLog(@"success===%@", success?@"YES":@"NO"); // 查询验证结果 NSMutableDictionary *data1 = [[NSMutableDictionary alloc] initWithContentsOfFile:filename]; NSLog(@"%@", data1);&#125; NSUserDefault： 支持的数据类型有NSString、 NSNumber、NSDate、 NSArray、NSDictionary、BOOL、NSInteger、NSFloat等系统定义的数据类型，如果要存放自定义的对象（如自定义的类对象），则必须将其转换成NSData存储。 123456789101112131415161718192021222324- (void) testUserDefaults&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; // 写入 [userDefaults setInteger:2 forKey:@"age"]; [userDefaults setObject:@"test_name" forKey:@"name"]; // 强制写入磁盘 [userDefaults synchronize]; // 读取 NSInteger age = [userDefaults integerForKey:@"age"]; NSString *name = [userDefaults objectForKey:@"name"]; NSLog(@"%ld===%@", age, name); //修改 [userDefaults setInteger:3 forKey:@"age"]; // 删除 [userDefaults removeObjectForKey:@"name"]; // 强制写入磁盘 [userDefaults synchronize]; NSLog(@"%ld===%@", [userDefaults integerForKey:@"age"], [userDefaults objectForKey:@"name"]);&#125; NSCoding：可存储自定义对象，局限：一次性做读取和存储操作，不可局部增量操作 entity实现NSCoding协议: 12345678910#import &lt;Foundation/Foundation.h&gt;#import "ZZBaseEntity.h"@interface TestUser : ZZBaseEntity&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) NSInteger pid;@end entity实现类重写encodeWithCoder、initWithCoder函数实现序列化和反序列化。 1234567891011121314151617181920212223242526272829303132333435#import "TestUser.h"@implementation TestUser- (void) setValue:(id)value forUndefinedKey:(NSString *)key&#123; if ([key isEqualToString:@"id"]) &#123; self.pid = [value integerValue]; &#125;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; if (self.name)&#123; [aCoder encodeObject:self.name forKey:@"name"]; &#125; if (self.age)&#123; [aCoder encodeInteger:self.age forKey:@"age"]; &#125; if (self.pid)&#123; [aCoder encodeInteger:self.pid forKey:@"pid"]; &#125;&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self == [super init]) &#123; self.name = [aDecoder decodeObjectForKey:@"name"]; self.age = [aDecoder decodeIntegerForKey:@"age"]; self.pid = [aDecoder decodeIntegerForKey:@"pid"]; &#125; return self;&#125;- (NSString *)description&#123; return [NSString stringWithFormat:@"%ld===%ld===%@", self.pid, self.age, self.name];&#125;@end 保存对象到NSUserDefaults： 12345678910111213141516- (void) testUserDefaults&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; // 写入 TestUser *user = [[TestUser alloc]init]; user.name = @"test_name"; user.age = 2; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:user]; [userDefaults setObject:data forKey:@"user"]; [userDefaults synchronize]; // 读取 NSData *data1 = [userDefaults objectForKey:@"user"]; TestUser *user1 = [NSKeyedUnarchiver unarchiveObjectWithData:data1]; NSLog(@"user1===%@", user1);&#125; Coredata： Coredata是对sqlite数据库ORM实现。 NSManagedObjectContext管理对象，上下文，持久性存储模型对象 NSManagedObjectModel数据模型，数据结构 NSPersistentStoreCoordinator连接数据库的 NSManagedObject数据记录 NSFetchRequest数据请求 NSEntityDescription表格实体结构 .xcdatamodel文件编译后为.momd或者.mom文件Sqlite：基本操作同Android中Sqlite。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 数据库模块搭建方案]]></title>
      <url>%2F2015%2F05%2F02%2Fandroid-db-plan%2F</url>
      <content type="text"><![CDATA[数据库作为App缓存设计的首选，存在一些开发的陷阱，同时需要考虑性能、开发效率和可维护性，笔者建议自行搭建数据库管理类，同时配合成熟的开源ORM框架快速搭建数据库模块。本方案采用ORM框架greenDAO，greenDAO是成熟的ORM框架，在性能和内存占用上很出色https://github.com/greenrobot/greenDAO Android数据库存在的问题： SQLite是数据库级别锁，同一个数据库连接可以多线程操作，同时读、写、读写操作，SQLite底层做了同步处理； 多个数据库连接，只可以多线程读操作，不可写或读写操作，否则会抛出锁表异常android.database.sqlite.SQLiteDatabaseLockedException: database is locked总结：多个数据库连接不能同时操作涉及到写的操作，多线程写操作必须保证一个数据库连接。 解决方案：1. 同步锁方案：考虑性能，建议使用ReadWriteLock，ReadWriteLock可以并发读，可以大幅减少读操作造成的锁开销； 在Application onCreate方法中创建全局唯一的ReadWriteLock； 1public static ReadWriteLock lock = new ReentrantReadWriteLock(false); 在DAO中调用Application的ReadWriteLock， 读操作前调用lock.readLock().lock();加锁，执行完毕调后调用lock.readLock.unlock();解锁； 写操作调用lock.writeLock().lock(); 加锁，执行完毕后调用lock.writeLock().unlock(); 解锁； 在每次读写操作前需要获取数据库连接，用完后关闭释放资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class UserInfoDAO &#123; private Context context; private ReadWriteLock lock; public TestDAO(Context context, ReadWriteLock lock)&#123; this.context = context; this.lock = lock; &#125; public SQLiteDatabase getConnection() &#123; SQLiteDatabase sqliteDatabase = null; try &#123; sqliteDatabase = new DatabaseHelper(context).getWritableDatabase(); &#125; catch (Exception e) &#123; &#125; return sqliteDatabase; &#125; public void insert(UserInfo userInfo)&#123; lock.writeLock().lock(); SQLiteDatabase db = null; try &#123; ContentValues values = new ContentValues(); values.put("name", userInfo.getName()); values.put("age", userInfo.getAge); db = getConnection(); if(db != null &amp;&amp; db.isOpen())&#123; db.insert("userInfo", null, values); &#125; &#125; catch (Exception e) &#123; &#125;finally&#123; if (db != null &amp;&amp; db.isOpen()) &#123; db.close(); &#125; myLock.writeLock().unlock(); &#125; &#125; public List&lt;UserInfo&gt; query()&#123; List&lt;UserInfo&gt; list = new ArrayList&lt;UserInfo&gt;(); lock.readLock().lock(); SQLiteDatabase db = null; try &#123; db = getConnection(); if(db != null &amp;&amp; db.isOpen())&#123; Cursor c = db.rawQuery("SELECT * FROM userInfo", null); UserInfo info; while (c.moveToNext()) &#123; info = new UserInfo(); info.setName(c.getString(c.getColumnIndex("name"))); info.setAge(c.getInt(c.getColumnIndex("age"))); list.add(info); &#125; &#125; &#125; catch (Exception e) &#123; &#125;finally&#123; if (db != null &amp;&amp; db.isOpen()) &#123; db.close(); &#125; lock.readLock().unlock(); &#125; return list; &#125;&#125; 2. 多数据库方案：每张table对应一个单独的db，由于SQLite在db层做了同步处理，故此方案支持读、写并发操作。 3. 单数据库连接方案： 此方案采用整个Application保证只有一个数据库连接，利用SQLite单数据库连接支持同时读写的特性； 对数据库操作抽象：数据库连接获取/关闭、数据库连接是否可用、获取数据库操作DAO管理类。DaoSession是greenDAO中DAO管理类，包含DAO的注册、获取、清理。 123456789101112131415161718192021222324public interface DatabaseManager &#123; /** * 获取数据库连接 */ void startup(Context mContext); /** * 关闭数据库 */ void shutdown(); /** * 检查数据库状态是否可用 * @return */ boolean checkDBStatus(); /** * 获取greenDAO DAO管理类 * @return */ DaoSession getDaoSession();&#125; 实现类DatabaseManagerImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DatabaseManagerImpl implements DatabaseManager &#123; private static final String DBNAME = "test_db"; private OpenHelper helper; private SQLiteDatabase db; private DaoSession daoSession; private Context mContext; @Override public void startup(Context mContext) &#123; this.mContext = mContext; if (LogUtils.DEBUG) &#123; QueryBuilder.LOG_SQL = true; QueryBuilder.LOG_VALUES = true; &#125; getOpenHelper(); db = helper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(db); daoSession = daoMaster.newSession(); &#125; @Override public void shutdown() &#123; if (daoSession != null) &#123; daoSession.clear(); &#125; if (db != null &amp;&amp; db.isOpen()) &#123; db.close(); &#125; &#125; private void getOpenHelper() &#123; if (helper != null) &#123; return; &#125; // TODO: release版本请使用ReleaseOpenHelper if (LogUtils.DEBUG) &#123; helper = new DaoMaster.DevOpenHelper(mContext, DBNAME, null); &#125; else &#123; helper = new ReleaseOpenHelper(mContext, DBNAME, null); &#125; &#125; @Override public boolean checkDBStatus() &#123; if (db == null || !db.isOpen()) &#123; getOpenHelper(); db = helper.getWritableDatabase(); &#125; if (db.isOpen()) &#123; return true; &#125; else &#123; if (LogUtils.DEBUG) &#123; LogUtils.d("database open fail."); &#125; return false; &#125; &#125; @Override public synchronized DaoSession getDaoSession() &#123; if (!checkDBStatus()) &#123; return null; &#125; if (daoSession == null) &#123; DaoMaster daoMaster = new DaoMaster(db); daoSession = daoMaster.newSession(); &#125; return daoSession; &#125;&#125; 在Application onCreate方法中创建DatabaseManager，并调用初始化方法startup，在此方法中获取数据库连接并保持，不释放，并通过数据库连接创建greenDao中DAO管理类; 在业务中需要数据库的地方，只需要调用getDaoSession获取DAO管理类调用相应的DAO即可。]]></content>
    </entry>

    
  
  
</search>
